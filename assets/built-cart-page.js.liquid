import { V as Vue } from './built-vue.esm-661ab646.js';
import { i as init } from './built-carousel-swiper-3bbece75.js';

/* global CartJS, Shopify */

Vue.config.errorHandler = function (err, vm, info) {
  var cart = CartJS.cart || window.vars.cartPayload;
  var logCart = {
    attributes: cart.attributes,
    item_count: cart.item_count,
    token: cart.token,
    items: cart.items.map(function (item) {
      return {
        title: item.title,
        handle: item.handle,
        product_id: item.product_id,
        variant_id: item.variant_id,
        variant_options: item.variant_options,
        url: item.url
      };
    })
  };
  console.log('Vue error', err);
  Rollbar.error("Vue error", {
    'err': err,
    'cart': JSON.stringify(logCart)
  }, function (err, data) {
    if (err) {
      console.log("Error while reporting error to Rollbar: ", err);
    } else {
      console.log("Error successfully reported to Rollbar. UUID:", data.result.uuid);
    }
  });

  if (window.location.pathname === '/cart') {
    console.log({
      'event': 'cart_clear',
      'cart': CartJS.cart || window.vars.cartPayload,
      'err': err,
      'vm': vm,
      'info': info
    });
    Rollbar.error("Cart clear triggered", {
      'cart': JSON.stringify(logCart),
      'err': err,
      'vm': vm,
      'info': info
    }, function (err, data) {
      if (err) {
        console.log("Error while reporting error to Rollbar: ", err);
      } else {
        console.log("Error successfully reported to Rollbar. UUID:", data.result.uuid);
      }

      CartJS.clear({
        success: function success() {
          window.location.reload();
        }
      });
    });
  }
};

var cartInit = false;
var invInit = false;
var storesSort = window.masterStores.map(function (a) {
  return a.name;
});

var emptyLoc = function emptyLoc(name) {
  var empty = {
    available: 0,
    distance: 0,
    id: "0",
    inStock: 0,
    name: name,
    pickupOption: false
  };
  return empty;
};

var emptyInventoryItem = window.masterStores.map(function (store) {
  return emptyLoc(store.name);
});
var emptyDelivery = {
  name: 'Delivery',
  ready: 'Unavailable for delivery',
  available: 0,
  inStock: 0,
  availability: {
    class: 'out',
    text: 'Out of Stock'
  },
  hours: '2-6 day delivery in Metro areas'
};

function addMasterStoresData(inventoryItem, item) {
  inventoryItem.locations = inventoryItem.locations.filter(function (loc) {
    return storesSort.indexOf(loc.name) !== -1;
  });
  var locs = inventoryItem.locations;
  var onlineInventoryLocs = locs.filter(function (loc) {
    return window.onlineInventoryStores.indexOf(loc.name) !== -1;
  });
  var onlineInventoryItem;

  if (onlineInventoryLocs.length > 0) {
    var totalAvailable = onlineInventoryLocs.map(function (loc) {
      return loc.available;
    }).reduce(function (a, b) {
      return a + b;
    }, 0);
    onlineInventoryItem = {
      name: 'Delivery',
      available: totalAvailable,
      inStock: totalAvailable > 0 ? 1 : 0,
      hours: '2-6 day delivery in Metro areas',
      availability: {
        class: totalAvailable > 2 ? 'in' : totalAvailable > 0 ? 'low' : 'out',
        text: totalAvailable > 2 ? 'In Stock' : totalAvailable > 0 ? 'Low Stock' : 'Out of Stock'
      },
      ready: totalAvailable > 0 ? 'Available for delivery' : 'Unavailable for delivery'
    };
  } else {
    onlineInventoryItem = {
      name: 'Delivery',
      ready: 'Unavailable for delivery',
      available: 0,
      inStock: 0,
      availability: {
        class: 'out',
        text: 'Out of Stock'
      },
      hours: '2-6 day delivery in Metro areas'
    };
  }

  inventoryItem.delivery = onlineInventoryItem;
  console.log(inventoryItem, item);
  var duplicateStores = window.masterStores.filter(function (loc) {
    return loc.duplicate;
  });
  duplicateStores.forEach(function (loc) {
    var alreadyAdded = inventoryItem.locations.find(function (obj) {
      return obj.name === loc.name;
    });

    if (!alreadyAdded) {
      var thisLoc = inventoryItem.locations.find(function (obj) {
        return obj.name === loc.duplicate;
      });

      if (thisLoc && (thisLoc.name !== 'Genesis' || item.grams <= 22000)) {
        var duplicateLoc = JSON.parse(JSON.stringify(thisLoc));
        duplicateLoc.name = loc.name;
        inventoryItem.locations.push(duplicateLoc);
      }
    }
  });

  var _loop = function _loop() {
    var masterLoc = window.masterStores[i];
    var alreadyAdded = inventoryItem.locations.find(function (obj) {
      return obj.name === masterLoc.name;
    });

    if (!alreadyAdded) {
      inventoryItem.locations.push(emptyLoc(masterLoc.name));
    }
  };

  for (var i = window.masterStores.length - 1; i >= 0; i--) {
    _loop();
  } //inventoryItem.locations = inventoryItem.locations.filter(loc => window.ccStores.indexOf(loc.name) !== -1);

}

function supplementCart(cart) {
  console.log(cart, invInit);

  for (var i = cart.items.length - 1; i >= 0; i--) {
    var item = cart.items[i];

    if (invInit[item.product_id] && invInit[item.product_id].product.variants[item.variant_id]) {
      var invItem = invInit[item.product_id].product.variants[item.variant_id].inventoryItem;
      addMasterStoresData(invItem, item);
      item.delivery = invItem.delivery;
      item.locations = invItem.locations;
    } else {
      console.log(i, 'No locations info for ' + item.title);
      Rollbar.warning("Empty Inventory Item assigned", {
        'title': item.title,
        'product_id': item.product_id,
        'variant_id': item.variant_id,
        'url': item.url
      });
      item.locations = JSON.parse(JSON.stringify(emptyInventoryItem));
      item.delivery = emptyDelivery;
    }
  }

  return cart;
}
/**
 * Attach listeners to open collapse elements
 */


var initCartDisplay = function initCartDisplay(cart) {
  window.cartDisplay = new Vue({
    el: '#cartDisplay',
    data: {
      cart: supplementCart(JSON.parse(JSON.stringify(cart))),
      masterStores: window.masterStores,
      pickupStores: window.masterStores.filter(function (loc) {
        return window.ccStores.indexOf(loc.name) !== -1;
      }),
      favStore: window.vars.favStore || {},
      deliveryOption: window.vars.deliveryOption,
      override: false
    },
    methods: {
      changeWholeData: function changeWholeData(newData, part) {
        var changeData = part ? this.$data[part] : this.$data;
        Object.keys(changeData).forEach(function (key) {
          return changeData[key] = null;
        });
        Object.entries(newData).forEach(function (entry) {
          return Vue.set(changeData, entry[0], entry[1]);
        });

        if (this.$data.override) {
          // TODO: Remove timeout and lock onto re-render
          setTimeout(function () {
            jQuery('.checkout-btn').click();
          }, 300);
        }
      },
      money: function money(price) {
        return "$" + (price / 100).toFixed(2);
      },
      updateQuantity: function updateQuantity(lineIndex, newQty) {
        console.log(lineIndex, newQty);
        CartJS.updateItem(lineIndex, newQty);
      },
      setFavStore: function setFavStore(event) {
        var masterStore = window.masterStores.find(function (obj) {
          return obj.id === event.target.value;
        });

        if (masterStore) {
          localStorage.setItem('favoritedStore', JSON.stringify(masterStore));
          window.vars.favStore = JSON.parse(localStorage.getItem('favoritedStore'));
          this.changeWholeData(window.vars.favStore, 'favStore');
          localStorage.setItem('deliveryOption', 'Click & Collect');
          window.vars.deliveryOption = localStorage.getItem('deliveryOption') || 'Delivery';
          this.$data.deliveryOption = window.vars.deliveryOption;
        }
      },
      setDeliveryOption: function setDeliveryOption(event) {
        localStorage.setItem('deliveryOption', event.target.value);
        window.vars.deliveryOption = localStorage.getItem('deliveryOption') || 'Delivery';
        this.$data.deliveryOption = window.vars.deliveryOption;
      },
      checkAvailability: function checkAvailability(item) {
        var app = this;

        if (!item.locations) {
          return 'out';
        }

        var checkLoc = item.delivery;

        if (app.deliveryOption !== 'Delivery') {
          checkLoc = item.locations.find(function (obj) {
            return obj.name === app.favStore.name;
          });
        }

        return checkLoc.inStock > 0 ? 'in' : 'out';
      },
      currentMax: function currentMax(item) {
        // Let availabilities = item.locations.map(a => a.available);
        // return Math.max(checkLoc);
        var app = this;
        var checkLoc = item.delivery;

        if (app.deliveryOption !== 'Delivery') {
          checkLoc = item.locations.find(function (obj) {
            return obj.name === app.favStore.name;
          });
        }

        return checkLoc.available;
      },
      deliveryMax: function deliveryMax(item) {
        var checkLoc = item.delivery;
        console.log('Delivery', checkLoc.available);
        return checkLoc.available;
      },
      favStoreMax: function favStoreMax(item) {
        // Let availabilities = item.locations.map(a => a.available);
        // return Math.max(checkLoc);
        var app = this;
        var checkLoc = item.locations.find(function (obj) {
          return obj.name === app.favStore.name;
        });
        console.log('favStore', checkLoc.available);
        return checkLoc ? checkLoc.available : 0;
      },
      availabilityMessages: function availabilityMessages(item) {
        var messages = [];
        var app = this;
        var delivery = item.delivery;
        var deliveryMessage = "<div class=\"" + (delivery.inStock ? item.quantity <= delivery.available ? 'available' : 'low' : 'unavailable') + "\"><p>" + (delivery.inStock ? item.quantity <= delivery.available ? 'Available' : 'Not all items available' : 'Unavailable') + " for delivery</p></div>";
        messages.push(deliveryMessage);

        if (app.favStore && app.favStore.name) {
          var favStoreInventory = item.locations.find(function (obj) {
            return obj.name === app.favStore.name;
          });
          var ccMessage = "<div class=\"" + (favStoreInventory.inStock ? item.quantity <= favStoreInventory.available ? 'available' : 'low' : 'unavailable') + "\"><p>" + (favStoreInventory.inStock ? item.quantity <= favStoreInventory.available ? 'Available' : 'Not all items available' : 'Unavailable') + " for click & collect</p></div>";
          messages.push(ccMessage);
        }

        return messages.join('');
      },
      cartModificationsMessage: function cartModificationsMessage() {
        var app = this;
        var items = app.$data.cart.items;
        var itemsToRemove = 0;

        for (var i = items.length - 1; i >= 0; i--) {
          var item = items[i];
          var checkLoc = item.delivery;

          if (app.deliveryOption !== 'Delivery') {
            checkLoc = item.locations.find(function (obj) {
              return obj.name === app.favStore.name;
            });
          }

          if (checkLoc.inStock < 1) {
            itemsToRemove++;
          }
        }

        if (itemsToRemove > 0) {
          return itemsToRemove + " " + (itemsToRemove > 1 ? 'items' : 'item') + " unavailable for " + app.deliveryOption + " will be removed from your cart";
        }

        return '';
      },
      prepareCart: function prepareCart(event) {
        var app = this;

        if (app.override) {
          return true;
        }

        var updateCartPayload = {};

        for (var i = app.cart.items.length - 1; i >= 0; i--) {
          var item = app.cart.items[i];
          var currentMax = app.currentMax(item);

          if (item.quantity > currentMax) {
            updateCartPayload[item.variant_id] = currentMax;
          }
        }

        if (JSON.stringify(updateCartPayload) === '{}') {
          return true;
        }

        event.preventDefault();
        CartJS.updateItemQuantitiesById(updateCartPayload, {
          success: function success() {
            app.$data.override = true;
          }
        });
        return false;
      }
    }
  });
  jQuery('.de-u-fade').addClass('in');
  jQuery('#cartSpinner').addClass('de-u-hidden');
};

jQuery(document).on('cart.ready', function (event, cart) {
  cartInit = cart;
  console.log('CART READY', event, cart);
  tryInit();
});
document.addEventListener('tomitLoaded', function () {
  return new Promise(function ($return, $error) {
    var _window, vars, tomitProductInventoryInfo, _window$tomitProductI, getProductsInventoryInformation, getVariantInventory, tomitCartPayload, tomitCartVariants, getVariantInventoryAndHandleErrors, inventoryInfo, missingInventoryVariants, inventoryInfoVariants, inventoryInfoVariantIDs, i, _variantInventory$pro, _inventoryProduct$pro, missingInventoryVariant, variantInventory, _Object$entries$, k, v, variantIndex, inventoryProductID, inventoryProduct, inventoryProductVariants;

    _window = window, vars = _window.vars, tomitProductInventoryInfo = _window.tomitProductInventoryInfo;
    _window$tomitProductI = window.tomitProductInventoryInfo, getProductsInventoryInformation = _window$tomitProductI.getProductsInventoryInformation, getVariantInventory = _window$tomitProductI.getVariantInventory;
    tomitCartPayload = vars.tomitCartPayload, tomitCartVariants = vars.tomitCartVariants;

    getVariantInventoryAndHandleErrors = function getVariantInventoryAndHandleErrors(vID) {
      return new Promise(function ($return, $error) {
        var response;

        var $Try_1_Post = function () {
          try {
            return $return(response);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_1_Catch = function (err) {
          try {
            console.error('Error getting inventory', err);
            response = undefined;
            return $Try_1_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(getVariantInventory(vID)).then(function ($await_6) {
            try {
              response = $await_6;
              return $Try_1_Post();
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }, $Try_1_Catch);
        } catch (err) {
          $Try_1_Catch(err);
        }
      });
    };

    console.log(1);
    return Promise.resolve(getProductsInventoryInformation(tomitCartPayload)).then(function ($await_7) {
      try {
        inventoryInfo = $await_7;
        console.log(2, inventoryInfo);

        var $Try_2_Post = function () {
          try {
            invInit = inventoryInfo;
            console.log('INV READY', inventoryInfo);
            tryInit();
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_2_Catch = function (err) {
          try {
            console.error('Error getting variant inventories', err);
            return $Try_2_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          inventoryInfoVariants = Object.entries(inventoryInfo).map(function (_ref) {
            var _v$product;

            var k = _ref[0],
                v = _ref[1];
            return v == null ? void 0 : (_v$product = v.product) == null ? void 0 : _v$product.variants;
          });
          inventoryInfoVariantIDs = Object.entries(inventoryInfo).map(function (_ref2) {
            var _v$product2;

            var k = _ref2[0],
                v = _ref2[1];
            return Object.keys(v == null ? void 0 : (_v$product2 = v.product) == null ? void 0 : _v$product2.variants);
          });
          inventoryInfoVariantIDs = inventoryInfoVariantIDs.reduce(function (acc, val) {
            return acc.concat(val);
          }, []);
          console.log(3, inventoryInfoVariantIDs);
          missingInventoryVariants = tomitCartVariants.filter(function (vID) {
            return inventoryInfoVariantIDs.indexOf(String(vID)) === -1;
          });
          console.log(4, missingInventoryVariants);

          if (missingInventoryVariants.length > 0) {
            i = missingInventoryVariants.length - 1;
            var $Loop_4_trampoline;

            function $Loop_4_step() {
              i--;
              return $Loop_4;
            }

            function $Loop_4() {
              if (i >= 0) {
                missingInventoryVariant = missingInventoryVariants[i];
                return Promise.resolve(getVariantInventoryAndHandleErrors(missingInventoryVariant)).then(function ($await_8) {
                  try {
                    variantInventory = $await_8;

                    if (variantInventory === undefined) {
                      return $return();
                    }

                    _Object$entries$ = Object.entries(variantInventory == null ? void 0 : (_variantInventory$pro = variantInventory.product) == null ? void 0 : _variantInventory$pro.variants)[0], k = _Object$entries$[0], v = _Object$entries$[1];
                    console.log(5, tomitCartVariants, k);
                    variantIndex = tomitCartVariants.indexOf(parseInt(k));
                    console.log(6, variantIndex);
                    inventoryProductID = tomitCartPayload[variantIndex];
                    console.log(7, inventoryProductID);
                    inventoryProduct = inventoryInfo[String(inventoryProductID)];
                    inventoryProductVariants = inventoryProduct == null ? void 0 : (_inventoryProduct$pro = inventoryProduct.product) == null ? void 0 : _inventoryProduct$pro.variants;
                    console.log(8, inventoryProduct);
                    inventoryProductVariants[k] = v;
                    return $Loop_4_step;
                  } catch ($boundEx) {
                    return $Try_2_Catch($boundEx);
                  }
                }, $Try_2_Catch);
              } else return [1];
            }

            return ($Loop_4_trampoline = function (q) {
              while (q) {
                if (q.then) return void q.then($Loop_4_trampoline, $Try_2_Catch);

                try {
                  if (q.pop) {
                    if (q.length) return q.pop() ? $Loop_4_exit.call(this) : q;else q = $Loop_4_step;
                  } else q = q.call(this);
                } catch (_exception) {
                  return $Try_2_Catch(_exception);
                }
              }
            }.bind(this))($Loop_4);

            function $Loop_4_exit() {
              return $If_3.call(this);
            }
          }

          function $If_3() {
            return $Try_2_Post();
          }

          return $If_3.call(this);
        } catch (err) {
          $Try_2_Catch(err);
        }
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }.bind(this), $error);
  });
});

function tryInit() {
  if (cartInit && invInit) {
    initCartDisplay(cartInit);
  }
}

jQuery(document).on('cart.requestComplete', function (event, cart) {
  window.cartDisplay.changeWholeData(supplementCart(cart), 'cart');
  jQuery('.js-de-cart__subtotal').text(Shopify.formatMoney(cart.total_price));
  jQuery('.afterpay-info strong').text(Shopify.formatMoney(cart.total_price / 4));
  jQuery('#CartCount').text(cart.item_count);

  if (window.vars.thresholdForGateways.afterpay.enabled && window.vars.thresholdForGateways.afterpay.threshold && cart) {
    displayPaymentGateway(cart.total_price, window.vars.thresholdForGateways.afterpay.threshold * 100, 'afterpay');
  }

  if (window.vars.thresholdForGateways.zipPay.enabled && window.vars.thresholdForGateways.zipPay.threshold && cart) {
    displayPaymentGateway(cart.total_price, window.vars.thresholdForGateways.zipPay.threshold * 100, 'zip-pay');
  }
});

function displayPaymentGateway(price, threshold, gateway) {
  var dNoneClassName = 'de-u-hidden';
  jQuery(".cart-" + gateway + "-info").toggleClass(dNoneClassName, price < threshold);
  jQuery(".cart-" + gateway + "-disabled-info").toggleClass(dNoneClassName, price >= threshold);
}

document.addEventListener('DOMContentLoaded', function () {
  console.log('hey...');
  init();
});
