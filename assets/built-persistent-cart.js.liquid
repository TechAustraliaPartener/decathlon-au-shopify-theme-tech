import { I as IS_CUSTOM_CHECKOUT, s as scriptsConfig, D as DEBUG } from './built-fetch-stores-13903880.js';
import { C as Cookies, c as commonjsGlobal, _ as _toConsumableArray } from './built-toConsumableArray-0fbe23f7.js';
import { r as removeItemFromLocalStorage, b as getObjectFromLocalStorage, c as setObjectInLocalStorage, d as getStorefrontAPITested, e as setStorefrontAPITestedState, s as sessionStorageAvailable, l as localStorageAvailable, f as cookiesAvailable } from './built-storage-f11703b1.js';

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

/**
 * A custom implementation (not a fork) of the NPM module `nanographql`
 * The original module stringified variables and then stringified the entire data object,
 * leading to a payload format that would not work with the Shopify Storefront API.
 * This version is amended to pass our ESLint setup
 * @see https://github.com/yoshuawuyts/nanographql
 */
var getOpname = /(query|mutation) ?([\w\d-_]+)? ?\(.*?\)? \{/;
function nanographql(str) {
  var _str = Array.isArray(str) ? str.join('') : str;

  var name = getOpname.exec(_str);
  return function (variables) {
    var data = {
      query: _str
    };
    if (variables) data.variables = variables;

    if (Array.isArray(name) && name[2]) {
      var operationName = name[2];

      if (operationName) {
        data.operationName = name[2];
      }
    }

    return JSON.stringify(data);
  };
}

/**
 * List of production domains
 * Can be set as a comma-delimited list via a `PRODUCTION_DOMAINS` environment variable
 */
var PRODUCTION_DOMAINS =  ['www.decathlon.com'];
/**
 * List of staging domains
 * Can be set as a comma-delimited list via a `STAGING_DOMAINS` environment variable
 */

var STAGING_DOMAINS =  ['testing-decathlon-usa.myshopify.com'];
/**
 * The production Persistent Cart app API URL
 */

var PRODUCTION_API_URL =  'https://persistent-cart-decathlonusa-p.herokuapp.com';
/**
 * The staging Persistent Cart app API URL
 */

var STAGING_API_URL =  'https://persistent-cart-decathlonusa-s.herokuapp.com';
/**
 * Persistent Cart client-side config
 */

var config = {
  /**
   * URL for sending GQL requests. Can be set on process.env or use a local
   * @TODO - How to setup for production (Discuss with DE Team)?
   * Consider removing local definition
   */
  get API_URL() {
    var LOCAL_API_URL = 'http://localhost:8080'; // Set default to local

    var persistentCartUrl = LOCAL_API_URL; // Because DRY

    var hostname = window.location.hostname; // Set to staging API URL if we match a staging domain
    // Regular Expressions are supported

    if (STAGING_DOMAINS.some(function (domain) {
      return hostname.match(new RegExp(domain));
    })) {
      persistentCartUrl = STAGING_API_URL;
    } // Set to production API URL if we match a production domain
    // Regular Expressions are supported


    if (PRODUCTION_DOMAINS.some(function (domain) {
      return hostname.match(new RegExp(domain));
    })) {
      persistentCartUrl = PRODUCTION_API_URL;
    } // Allow override via `DECATHLON_PERSISTENT_CART_URL` environment variable


    return ( persistentCartUrl) + "/shopify/graphql";
  },

  STORAGE: {
    PREFIX: 'de_pc_',

    get SHOPIFY_CART() {
      return this.PREFIX + "shopify_cart";
    },

    get LOGGED_IN() {
      return this.PREFIX + "logged_in";
    }

  },
  SHOPIFY_API: {
    GET_CART: '/cart.js',
    UPDATE_CART: '/cart/update.js',
    ADD_TO_CART: '/cart/add.js'
  },
  COOKIES: {
    CART: 'cart',
    CART_TS: 'cart_ts',
    CART_SIG: 'cart_sig',
    CART_CURRENCY: 'cart_currency'
  },

  get ALL_CART_COOKIES() {
    var _this = this;

    return Object.keys(this.COOKIES).map(function (key) {
      return _this.COOKIES[key];
    });
  },

  get CART_COOKIE() {
    return this.COOKIES.CART;
  }

};

var STOREFRONT_API = scriptsConfig.STOREFRONT_API,
    NO_CACHE_HEADERS = scriptsConfig.NO_CACHE_HEADERS;
/**
 * Generic function for issuing a GQL query or mutation
 * @param {*} query - A GQL query
 * @param {Object} data - Data to pass to the query
 * @param {string} [url] - A request URL, which, if passed, will override the default
 * @param {Object} [extraConfig = {}] - Additional configuration used to add to the existing request configuration
 * @returns {Promise<Object>} - Data returned from the GQL query or mutation
 */

var makeRequest = function makeRequest(query, data, url, extraConfig) {
  if (extraConfig === void 0) {
    extraConfig = {};
  }

  return fetch(url || config.API_URL, {
    body: query(data),
    method: 'POST',
    headers: Object.assign({
      'Content-Type': 'application/json',
      Accept: 'application/json'
    }, extraConfig.headers)
  }).then(function (response) {
    if (!response.ok) {
      var message = response.statusText;
      throw new Error("Failed GQL request. Status: " + response.status + (message && "; message: " + message));
    }

    return response.json();
  })
  /**
   * GQL returns either only `data` or `errors`, which is an array of objects.
   * `errors` are the result of a malformed request (not HTTP errors)
   */
  .then(function (_ref) {
    var data = _ref.data,
        errors = _ref.errors;

    if (errors) {
      // Just reduce all error messages to a comma-delimited string (only one string if there's only one error)
      var messages = errors.reduce(function (acc, err, idx) {
        return "" + acc + (idx > 0 ? ', ' : '') + err.message;
      }, ''); // Log a new error with one or more messages about why this request failed, for debugging purposes

      console.info('PC: ', messages);
    }

    return data;
  });
};
/**
 * Make a request, passing along extra headers to enforce no caching of the response
 * @param {*} query - A GQL query
 * @param {Object} data - Data to pass to the query
 * @param {string} [url] - A request URL, which, if passed, will override the default
 * @param {Object} [extraConfig = {}] - Additional configuration used to add to the existing request configuration
 * @returns {Promise<Object>} - Data returned from the GQL query or mutation
 */

var makeUncachedRequest = function makeUncachedRequest(query, data, url, extraConfig) {
  if (extraConfig === void 0) {
    extraConfig = {};
  }

  return makeRequest(query, data, url, {
    headers: Object.assign({}, NO_CACHE_HEADERS, extraConfig.headers)
  });
};
/**
 * Make a GraphQL request to the Shopify Storefront API by passing an override URL and additional configuration
 * to the underlying `makeRequest` master GraphQL request function
 * @param {*} query - A tagged template literal that will be used to create a GraphQL request using passed-in data
 * @param {Object} data - The data to be passed to a GraphQL query
 * @returns {Promise<Object>} - Data returned from the GQL query or mutation
 */

var makeShopifyStorefrontRequest = function makeShopifyStorefrontRequest(query, data) {
  var headers = {};
  headers[STOREFRONT_API.HEADER_NAME] = STOREFRONT_API.KEY;
  return makeUncachedRequest(query, data, STOREFRONT_API.URL, {
    headers: headers
  });
};

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["\n  query($customerID: ID!) {\n    getCustomer(customerID: $customerID) {\n      customerID\n      cart\n      cartID\n    }\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  mutation($customerID: ID!, $cart: JSON) {\n    createOrUpdateCustomer(customerID: $customerID, cart: $cart) {\n      customerID\n      cart\n      cartID\n    }\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var API_URL = config.API_URL;
/**
 * Request to create or update a customer in the DB
 * @param {Object} params
 * @param {*} params.mutation - A GQL mutation for the PC application to create or update a customer with a cart
 * @param {string} params.customerID - A GQL ID
 * @param {Object} params.cart - A Shopify cart
 * @returns {Promise<Object>} - A customer (with cart) from our DB
 */

var createOrUpdateCustomerRequest = function createOrUpdateCustomerRequest(_ref) {
  var mutation = _ref.mutation,
      customerID = _ref.customerID,
      cart = _ref.cart;
  return makeUncachedRequest(mutation, {
    customerID: customerID,
    cart: cart
  }, API_URL).then(function (data) {
    return data.createOrUpdateCustomer;
  }).catch(function (error) {
    throw new Error("Error creating or updating customer in database: " + error.message);
  });
};
/**
 * Takes a customerID and queries our DB for a customer
 * @param {Object} params
 * @param {*} params.query - A GQL query for sending data to the PC GQL endpoint to get a customer from the DB
 * @param {string} params.customerID - A customer ID string
 * @returns {Promise<Object|null>} - A customer from the DB (or null if there is no customer with this ID)
 */


var getCustomerRequest = function getCustomerRequest(_ref2) {
  var query = _ref2.query,
      customerID = _ref2.customerID;
  return makeUncachedRequest(query, {
    customerID: customerID
  }, API_URL).then(function (data) {
    return data.getCustomer;
  }).catch(function (error) {
    throw new Error("Error getting customer from database: " + error.message);
  });
};
/**
 * A GQL mutation for creating or updating a customer with a cart object
 */


var createOrUpdateCustomerMutation = nanographql(_templateObject());
/**
 * A GQL query for getting a customer by customerID from the DB
 */

var getCustomerQuery = nanographql(_templateObject2());
/**
 * Wraps the request, using the default query for getting a full customer from the GQL interface
 * @param {string} customerID
 * @returns {Object} customer - From the database
 */

var getCustomer = function getCustomer(customerID) {
  return getCustomerRequest({
    query: getCustomerQuery,
    customerID: customerID
  });
};
/**
 * Wraps the request to a GQL mutation passing in the mutation and data for the request
 * @param {Object} params
 * @param {string} params.customerID
 * @param {Object} params.cart - A cart object
 * @returns {Object} customer - A newly created or updated customer object
 */


var createOrUpdateCustomer = function createOrUpdateCustomer(_ref3) {
  var customerID = _ref3.customerID,
      cart = _ref3.cart;
  return createOrUpdateCustomerRequest({
    mutation: createOrUpdateCustomerMutation,
    customerID: customerID,
    cart: cart
  });
};

// @ts-check
var _config$STORAGE = config.STORAGE,
    LOGGED_IN = _config$STORAGE.LOGGED_IN,
    SHOPIFY_CART = _config$STORAGE.SHOPIFY_CART;
/**
 * Get a saved Shopify cart from localStorage
 * @returns {Object} cart - The JSON.parsed cart object from localStorage
 */

var getStoredShopifyCart = function getStoredShopifyCart() {
  return getObjectFromLocalStorage(SHOPIFY_CART);
};
/**
 * Sets a Shopify cart object in localStorage
 * @param {Object} cart - The cart object to be stored
 */

var setStoredShopifyCart = function setStoredShopifyCart(cart) {
  return setObjectInLocalStorage(SHOPIFY_CART, cart);
};
/**
 * Removes a Shopify cart object in localStorage
 */

var removeStoredShopifyCart = function removeStoredShopifyCart() {
  return removeItemFromLocalStorage(SHOPIFY_CART);
};
/**
 * Sets a key in localStorage flagging that the customer was logged in as of this times
 */

var setWasLoggedIn = function setWasLoggedIn() {
  return setObjectInLocalStorage(LOGGED_IN, true);
};
/**
 * Gets a boolean in localStorage flagging the state of customer login
 * Returns false if the key is not set
 * @returns {boolean} isLoggedIn
 */

var getWasLoggedIn = function getWasLoggedIn() {
  return Boolean(getObjectFromLocalStorage(LOGGED_IN));
};
/**
 * Removes a boolean in localStorage flagging the state of customer login
 */

var removeWasLoggedIn = function removeWasLoggedIn() {
  return removeItemFromLocalStorage(LOGGED_IN);
};
/**
 * A plain object for saving off some values used in our main chain of async functions,
 * across functions
 */

var cache = {
  customerID: null,
  customer: null,
  // Will store the cart returned by Shopify after setting the `cart` cookie stored in the DB
  masterShopifyCart: null,
  customerCartExpired: false,
  currentCartCount: 0,
  setNewCustomerOrCart: false
};

function _templateObject2$1() {
  var data = _taggedTemplateLiteralLoose(["\n  query testStorefrontAPIQuery {\n    shop {\n      name\n    }\n  }\n"]);

  _templateObject2$1 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject$1() {
  var data = _taggedTemplateLiteralLoose(["\n  mutation checkoutCreate($input: CheckoutCreateInput!) {\n    checkoutCreate(input: $input) {\n      checkout {\n        id\n        webUrl\n      }\n      checkoutUserErrors {\n        code\n        field\n        message\n      }\n    }\n  }\n"]);

  _templateObject$1 = function _templateObject() {
    return data;
  };

  return data;
}
/**
 * A tagged template literal that will take data and return the object to be used
 * to make a GraphQL request to the Shopify Storefront API, to return a new checkout object.
 * Currently has no schema to be tested against, so ESLint-wrapped to ignore schema checks.
 */

/* eslint-disable graphql/template-strings */

var createCheckoutMutation = nanographql(_templateObject$1());
/* eslint-enable */

/**
 * Simple Storefront API GQL query to be used as a health check
 */

/* eslint-disable graphql/template-strings */

var testStorefrontAPIQuery = nanographql(_templateObject2$1());
/* eslint-enable */

/**
 * Create a request for a new Shopify checkout from the Storefront API
 * Passes off to a wrapper over our generic makeShopifyStorefrontRequest function to issue a GraphQL
 * request to the passed-in URL with appropriate headers set for accessing the Storefront API
 * @param {Object} params
 * @param {*} params.mutation - A GraphQL query template
 * @param {Object} params.input - The data to be used within the query (mutation)
 * @returns {Promise<Object>} - A Shopify checkout object
 */

var createCheckoutRequest = function createCheckoutRequest(_ref) {
  var mutation = _ref.mutation,
      input = _ref.input;
  return makeShopifyStorefrontRequest(mutation, {
    input: input
  }).then(function (data) {
    return data.checkoutCreate;
  }).catch(function (error) {
    throw new Error("Error getting customer from database: " + error.message);
  });
};
/**
 * @see https://help.shopify.com/en/api/storefront-api/reference/object/checkoutusererror
 * @typedef {Object} CheckoutUserError
 * @property {string|number} [code]
 * @property {string} field
 * @property {string} message
 */

/**
 * @see https://help.shopify.com/en/api/storefront-api/reference/object/checkout
 * @typedef {Object} CreateCheckoutResponse
 * @property {Object} checkout
 * @property {string} checkout.id
 * @property {string} checkout.webUrl
 * @property {CheckoutUserError[]} [checkoutUserErrors]
 */

/**
 * Take an input object to be used to create a request to the Shopify Storefront API
 * @param {Object} input - The variables object to be passed to the query (mutation)
 * @returns {Promise<CreateCheckoutResponse>} - A Shopify checkout object
 */


var createCheckout = function createCheckout(input) {
  return createCheckoutRequest({
    mutation: createCheckoutMutation,
    input: input
  });
};
/**
 * Test that a request to the Storefront API GraphQL endpoint works and
 * returns a value
 * @returns {Promise<Boolean>} - The request succeeded
 */

var testStorefrontAPI = function testStorefrontAPI() {
  return makeShopifyStorefrontRequest(testStorefrontAPIQuery).then(function (data) {
    return Boolean(data.shop && data.shop.name);
  }).catch(function (error) {
    console.error('Storefront API Test Request Failed:', error);
    return false;
  });
};

// @ts-check
/**
 * 1. Check to see if the Storefront API has been tested (health check), and the
 *    result persisted (it is set to eventually expire and eventually be
 *    re-tested)
 * 2. If there is no persisted test result, query the API and persist the result
 * 3. Return the result
 * @returns {Promise<boolean>} Storefront API has been tested recently
 * and is working
 */

var persistedStorefrontAPITest = function persistedStorefrontAPITest() {
  return new Promise(function ($return, $error) {
    var storefrontAPIWorks;
    storefrontAPIWorks = getStorefrontAPITested();

    if (storefrontAPIWorks === null) {
      return Promise.resolve(testStorefrontAPI()).then(function ($await_2) {
        try {
          storefrontAPIWorks = $await_2;
          setStorefrontAPITestedState(storefrontAPIWorks);
          return $If_1.call(this);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }

    function $If_1() {
      return $return(storefrontAPIWorks);
    }

    return $If_1.call(this);
  });
};

// @ts-check

/**
 * @typedef {Object} LineItem - Item variant and quantity objects, formatted for
 * using in a Shopify Ajax API query
 * @property {number} id - A variant ID
 * @property {number} quantity - A quantity for a variant (line item) in a cart
 */

/**
 * Get items from a Shopify cart or the cart in the DB
 * Note that the cart returned by a webhook does not match the
 * structure of a cart returned by the AJAX API
 * @param {Item[]} items - Items extracted from a cart
 * @returns {LineItem[]} - Query-ready line-item objects
 */
var getLineItems = function getLineItems(items) {
  return items.map(function (_ref) {
    var id = _ref.variant_id,
        quantity = _ref.quantity;
    return {
      id: id,
      quantity: quantity
    };
  });
};
/**
 * Get items from a cart
 * @param {Cart} cart - A Shopify cart
 * @returns {Item[] | []}
 */


var getItemsFromCart = function getItemsFromCart(cart) {
  return cart && (cart.items || cart.line_items) || [];
}; // @TODO - implement and remove comments

/**
 * Merges two carts to produce a merged object of line-item details (variant_id and quantity)
 * This array should be used to update an existing Shopify cart in a single request
 * @see https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#update-cart
 * @param {Object|null} cart1 - One cart to reconcile
 * @param {Object|null} cart2 - Another cart to reconcile
 * @returns {Object.<string,number>} mergedCart - Object of line_item key/value pairs,
 * where the key is a variant_id (id property) the value is a quantity.
 * If the variant_id of two line items is identical, the quantity will be accumulated to a single line_item
 */


var cartReconciler = function cartReconciler(cart1, cart2) {
  /**
   * Get the line items for both carts (Our DB and from Shopify),
   * as an array of objects with ids an quantities
   */
  var combinedCart = [].concat(_toConsumableArray(getLineItems(getItemsFromCart(cart1))), _toConsumableArray(getLineItems(getItemsFromCart(cart2))));
  /**
   * Merge Shopify and DB cart line_item objects to a single array,
   * combining quantities for identical line_items
   */

  return combinedCart.reduce(function (acc, curr) {
    // Does the current item's id exist on the accumulated object?
    var matching = acc[curr.id]; // If so, add to quantity for the existing ID, else add this id to the
    // add the current quantity to a matching item or to 0 if it doesn't exist

    acc[curr.id] = (matching || 0) + curr.quantity;
    return acc;
  }, {});
};

var CART_COOKIE = config.CART_COOKIE,
    ALL_CART_COOKIES = config.ALL_CART_COOKIES;
/**
 * Sets the cart cookie
 * @param {string} cartId The cookie to set
 */

var setCartCookie = function setCartCookie(cartId) {
  return Cookies.set(CART_COOKIE, cartId);
};
/**
 * Get the cart cookie value
 */

var getCartCookie = Cookies.get(CART_COOKIE);
/**
 * Remove the cart cookie
 */

var removeCartCookie = function removeCartCookie() {
  return Cookies.remove(CART_COOKIE);
};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */

function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;

  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }

  return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */


function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
/** Used for built-in method references. */


var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */


function isPlainObject(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var lodash_isplainobject = isPlainObject;

/**
 * Sets up decorators or listeners on the AJAX Add-To-Cart functionality
 * of the Shopify store. If an add-to-cart event is detected, this
 * will call the initialization of the Persistent Cart client,
 * which will then determine whether to add a customer to the persistent-cart app
 * database, with the newly updated cart.
 *
 * This is needed for cases when a new customer logs in with an empty cart,
 * adds one or more items to their cart, and never reloads the page during
 * that session.
 *
 * @see /assets/ajax-cart.js(.liquid) for reference
 * @param {function(number)} persistentCartInit - An initialization function (callback) from
 * the main JS.
 * Takes the line_item quantity from an item successfully added to the cart.
 * This callback is called after an item is added to the cart using AJAX (no page reload).
 */

var onCartAjaxUpdated = function onCartAjaxUpdated(persistentCartInit) {
  // Check for the ShopifyAPI object, and abort if it does not exist
  var ShopifyAPI = window.ShopifyAPI;

  if (!ShopifyAPI || !ShopifyAPI.addItemFromForm) {
    return;
  }
  /**
   * Decorates function arguments to Shopify.addItemFromForm
   * Finds which argument to those functions is a Shopify line_item
   * This value is obtained during the triggering of the callback (function),
   * which is passed to the "success" property of the jQuery AJAX call used
   * by the Shopify.addItemFromForm method - aka, the "add-to-cart" AJAX success event
   *
   * @param {function} fn - A function that is an argument to ShopifyAPI.addItemFromForm
   * @returns {function} - The decorated function argument to Shopify.addItemFromForm.
   * Success adding an item can now be captured used to trigger the Persistent Cart,
   * to add a customer to the database without a page reload.
   */


  var argDecorator = function argDecorator(fn) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Check that this argument is a product by checking both variant_id and quantity properties
      var lineItemObject = args.find( // Ensure that arg is a JS object before using prop in object checks
      function (arg) {
        return lodash_isplainobject(arg) && 'variant_id' in arg && 'quantity' in arg;
      });

      if (lineItemObject) {
        // Initialize the application, passing in the quantity of the item just added to the cart
        persistentCartInit(lineItemObject.quantity);
      }

      return fn.apply(void 0, args);
    };
  };
  /**
   * Map over the arguments of the Shopify.addItemFromForm method.
   * For arguments that are functions, pass to another decorator
   * which detects which argument of that function is a product that
   * was added to the cart via AJAX. This is the signal that an
   * item was added to the cart.
   * @param {...*} args - The original arguments passed to ShopifyAPI.addItemFromForm
   * @returns {function} - The decorated addItemFromForm method
   */


  var originalShopifyAddItemFromForm = ShopifyAPI.addItemFromForm;

  ShopifyAPI.addItemFromForm = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var newArgs = args.map(function (arg) {
      return typeof arg === 'function' ? argDecorator(arg) : arg;
    });
    return originalShopifyAddItemFromForm.apply(void 0, _toConsumableArray(newArgs));
  };
};

/**
 * Updates the "cart count" in the corner. If there is no cart count, does nothing
 * @param {number} count
 */
var updateCartUI = function updateCartUI(count) {
  var el = document.querySelector('.js-cart-count');
  if (!el) return;
  el.innerText = count;
};

var LOGOUT = scriptsConfig.SELECTORS.LOGOUT;
/**
 * LOGOUT HANDLING
 * Clear the cart cookie on logout
 */

var logoutHandler = function logoutHandler() {
  removeCartCookie();
};

var logoutHandlerInit = function logoutHandlerInit() {
  var logoutLink = document.querySelector(LOGOUT);

  if (logoutLink) {
    logoutLink.addEventListener('click', logoutHandler);
  }
};

(function () {
  var h;

  function l(a) {
    var c = 0;
    return function () {
      return c < a.length ? {
        done: !1,
        value: a[c++]
      } : {
        done: !0
      };
    };
  }

  var m = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, c, b) {
    if (a == Array.prototype || a == Object.prototype) return a;
    a[c] = b.value;
    return a;
  };

  function n(a) {
    a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];

    for (var c = 0; c < a.length; ++c) {
      var b = a[c];
      if (b && b.Math == Math) return b;
    }

    throw Error("Cannot find global object");
  }

  var p = n(this);

  function r(a, c) {
    if (c) {
      for (var b = p, d = a.split("."), e = 0; e < d.length - 1; e++) {
        var f = d[e];
        f in b || (b[f] = {});
        b = b[f];
      }

      d = d[d.length - 1];
      e = b[d];
      f = c(e);
      f != e && null != f && m(b, d, {
        configurable: !0,
        writable: !0,
        value: f
      });
    }
  }

  r("Symbol", function (a) {
    function c(e) {
      if (this instanceof c) throw new TypeError("Symbol is not a constructor");
      return new b("jscomp_symbol_" + (e || "") + "_" + d++, e);
    }

    function b(e, f) {
      this.o = e;
      m(this, "description", {
        configurable: !0,
        writable: !0,
        value: f
      });
    }

    if (a) return a;

    b.prototype.toString = function () {
      return this.o;
    };

    var d = 0;
    return c;
  });
  r("Symbol.iterator", function (a) {
    if (a) return a;
    a = Symbol("Symbol.iterator");

    for (var c = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), b = 0; b < c.length; b++) {
      var d = p[c[b]];
      "function" === typeof d && "function" != typeof d.prototype[a] && m(d.prototype, a, {
        configurable: !0,
        writable: !0,
        value: function value() {
          return u(l(this));
        }
      });
    }

    return a;
  });

  function u(a) {
    a = {
      next: a
    };

    a[Symbol.iterator] = function () {
      return this;
    };

    return a;
  }

  function v(a) {
    var c = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return c ? c.call(a) : {
      next: l(a)
    };
  }

  var w;
  if ("function" == typeof Object.setPrototypeOf) w = Object.setPrototypeOf;else {
    var y;

    a: {
      var z = {
        u: !0
      },
          A = {};

      try {
        A.__proto__ = z;
        y = A.u;
        break a;
      } catch (a) {}

      y = !1;
    }

    w = y ? function (a, c) {
      a.__proto__ = c;
      if (a.__proto__ !== c) throw new TypeError(a + " is not extensible");
      return a;
    } : null;
  }
  var B = w;

  function C() {
    this.h = !1;
    this.f = null;
    this.m = void 0;
    this.b = 1;
    this.l = this.v = 0;
    this.g = null;
  }

  function D(a) {
    if (a.h) throw new TypeError("Generator is already running");
    a.h = !0;
  }

  C.prototype.i = function (a) {
    this.m = a;
  };

  C.prototype.j = function (a) {
    this.g = {
      w: a,
      A: !0
    };
    this.b = this.v || this.l;
  };

  C.prototype["return"] = function (a) {
    this.g = {
      "return": a
    };
    this.b = this.l;
  };

  function E(a, c) {
    a.b = 3;
    return {
      value: c
    };
  }

  function F(a) {
    this.a = new C();
    this.B = a;
  }

  F.prototype.i = function (a) {
    D(this.a);
    if (this.a.f) return G(this, this.a.f.next, a, this.a.i);
    this.a.i(a);
    return H(this);
  };

  function I(a, c) {
    D(a.a);
    var b = a.a.f;
    if (b) return G(a, "return" in b ? b["return"] : function (d) {
      return {
        value: d,
        done: !0
      };
    }, c, a.a["return"]);
    a.a["return"](c);
    return H(a);
  }

  F.prototype.j = function (a) {
    D(this.a);
    if (this.a.f) return G(this, this.a.f["throw"], a, this.a.i);
    this.a.j(a);
    return H(this);
  };

  function G(a, c, b, d) {
    try {
      var e = c.call(a.a.f, b);
      if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object");
      if (!e.done) return a.a.h = !1, e;
      var f = e.value;
    } catch (g) {
      return a.a.f = null, a.a.j(g), H(a);
    }

    a.a.f = null;
    d.call(a.a, f);
    return H(a);
  }

  function H(a) {
    for (; a.a.b;) {
      try {
        var c = a.B(a.a);
        if (c) return a.a.h = !1, {
          value: c.value,
          done: !1
        };
      } catch (b) {
        a.a.m = void 0, a.a.j(b);
      }
    }

    a.a.h = !1;

    if (a.a.g) {
      c = a.a.g;
      a.a.g = null;
      if (c.A) throw c.w;
      return {
        value: c["return"],
        done: !0
      };
    }

    return {
      value: void 0,
      done: !0
    };
  }

  function J(a) {
    this.next = function (c) {
      return a.i(c);
    };

    this["throw"] = function (c) {
      return a.j(c);
    };

    this["return"] = function (c) {
      return I(a, c);
    };

    this[Symbol.iterator] = function () {
      return this;
    };
  }

  function K(a, c) {
    var b = new J(new F(c));
    B && B(b, a.prototype);
    return b;
  }

  if ("undefined" !== typeof Blob && ("undefined" === typeof FormData || !FormData.prototype.keys)) {
    var L = function L(a, c) {
      for (var b = 0; b < a.length; b++) {
        c(a[b]);
      }
    },
        M = function M(a, c, b) {
      return c instanceof Blob ? [String(a), c, void 0 !== b ? b + "" : "string" === typeof c.name ? c.name : "blob"] : [String(a), String(c)];
    },
        N = function N(a, c) {
      if (a.length < c) throw new TypeError(c + " argument required, but only " + a.length + " present.");
    },
        O = function O(a) {
      var c = v(a);
      a = c.next().value;
      var b = c.next().value;
      c = c.next().value;
      b instanceof Blob && (b = new File([b], c, {
        type: b.type,
        lastModified: b.lastModified
      }));
      return [a, b];
    },
        P = "object" === typeof globalThis ? globalThis : "object" === typeof window ? window : "object" === typeof self ? self : this,
        Q = P.FormData,
        R = P.XMLHttpRequest && P.XMLHttpRequest.prototype.send,
        S = P.Request && P.fetch,
        T = P.navigator && P.navigator.sendBeacon,
        U = P.Element && P.Element.prototype,
        V = P.Symbol && Symbol.toStringTag;

    V && (Blob.prototype[V] || (Blob.prototype[V] = "Blob"), "File" in P && !File.prototype[V] && (File.prototype[V] = "File"));

    try {
      new File([], "");
    } catch (a) {
      P.File = function (c, b, d) {
        c = new Blob(c, d);
        d = d && void 0 !== d.lastModified ? new Date(d.lastModified) : new Date();
        Object.defineProperties(c, {
          name: {
            value: b
          },
          lastModifiedDate: {
            value: d
          },
          lastModified: {
            value: +d
          },
          toString: {
            value: function value() {
              return "[object File]";
            }
          }
        });
        V && Object.defineProperty(c, V, {
          value: "File"
        });
        return c;
      };
    }

    var W = function W(a) {
      this.c = [];
      var c = this;
      a && L(a.elements, function (b) {
        if (b.name && !b.disabled && "submit" !== b.type && "button" !== b.type && !b.matches("form fieldset[disabled] *")) if ("file" === b.type) {
          var d = b.files && b.files.length ? b.files : [new File([], "", {
            type: "application/octet-stream"
          })];
          L(d, function (e) {
            c.append(b.name, e);
          });
        } else "select-multiple" === b.type || "select-one" === b.type ? L(b.options, function (e) {
          !e.disabled && e.selected && c.append(b.name, e.value);
        }) : "checkbox" === b.type || "radio" === b.type ? b.checked && c.append(b.name, b.value) : (d = "textarea" === b.type ? b.value.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n") : b.value, c.append(b.name, d));
      });
    };

    h = W.prototype;

    h.append = function (a, c, b) {
      N(arguments, 2);
      this.c.push(M(a, c, b));
    };

    h["delete"] = function (a) {
      N(arguments, 1);
      var c = [];
      a = String(a);
      L(this.c, function (b) {
        b[0] !== a && c.push(b);
      });
      this.c = c;
    };

    h.entries = function c() {
      var b,
          d = this;
      return K(c, function (e) {
        1 == e.b && (b = 0);
        if (3 != e.b) return b < d.c.length ? e = E(e, O(d.c[b])) : (e.b = 0, e = void 0), e;
        b++;
        e.b = 2;
      });
    };

    h.forEach = function (c, b) {
      N(arguments, 1);

      for (var d = v(this), e = d.next(); !e.done; e = d.next()) {
        var f = v(e.value);
        e = f.next().value;
        f = f.next().value;
        c.call(b, f, e, this);
      }
    };

    h.get = function (c) {
      N(arguments, 1);
      var b = this.c;
      c = String(c);

      for (var d = 0; d < b.length; d++) {
        if (b[d][0] === c) return O(b[d])[1];
      }

      return null;
    };

    h.getAll = function (c) {
      N(arguments, 1);
      var b = [];
      c = String(c);
      L(this.c, function (d) {
        d[0] === c && b.push(O(d)[1]);
      });
      return b;
    };

    h.has = function (c) {
      N(arguments, 1);
      c = String(c);

      for (var b = 0; b < this.c.length; b++) {
        if (this.c[b][0] === c) return !0;
      }

      return !1;
    };

    h.keys = function b() {
      var d = this,
          e,
          f,
          g,
          k,
          q;
      return K(b, function (t) {
        1 == t.b && (e = v(d), f = e.next());

        if (3 != t.b) {
          if (f.done) {
            t.b = 0;
            return;
          }

          g = f.value;
          k = v(g);
          q = k.next().value;
          return E(t, q);
        }

        f = e.next();
        t.b = 2;
      });
    };

    h.set = function (b, d, e) {
      N(arguments, 2);
      b = String(b);
      var f = [],
          g = M(b, d, e),
          k = !0;
      L(this.c, function (q) {
        q[0] === b ? k && (k = !f.push(g)) : f.push(q);
      });
      k && f.push(g);
      this.c = f;
    };

    h.values = function d() {
      var e = this,
          f,
          g,
          k,
          q,
          t;
      return K(d, function (x) {
        1 == x.b && (f = v(e), g = f.next());

        if (3 != x.b) {
          if (g.done) {
            x.b = 0;
            return;
          }

          k = g.value;
          q = v(k);
          q.next();
          t = q.next().value;
          return E(x, t);
        }

        g = f.next();
        x.b = 2;
      });
    };

    W.prototype._asNative = function () {
      for (var d = new Q(), e = v(this), f = e.next(); !f.done; f = e.next()) {
        var g = v(f.value);
        f = g.next().value;
        g = g.next().value;
        d.append(f, g);
      }

      return d;
    };

    W.prototype._blob = function () {
      for (var d = "----formdata-polyfill-" + Math.random(), e = [], f = v(this), g = f.next(); !g.done; g = f.next()) {
        var k = v(g.value);
        g = k.next().value;
        k = k.next().value;
        e.push("--" + d + "\r\n");
        k instanceof Blob ? e.push('Content-Disposition: form-data; name="' + g + '"; filename="' + k.name + '"\r\nContent-Type: ' + ((k.type || "application/octet-stream") + "\r\n\r\n"), k, "\r\n") : e.push('Content-Disposition: form-data; name="' + g + '"\r\n\r\n' + k + "\r\n");
      }

      e.push("--" + d + "--");
      return new Blob(e, {
        type: "multipart/form-data; boundary=" + d
      });
    };

    W.prototype[Symbol.iterator] = function () {
      return this.entries();
    };

    W.prototype.toString = function () {
      return "[object FormData]";
    };

    U && !U.matches && (U.matches = U.matchesSelector || U.mozMatchesSelector || U.msMatchesSelector || U.oMatchesSelector || U.webkitMatchesSelector || function (d) {
      d = (this.document || this.ownerDocument).querySelectorAll(d);

      for (var e = d.length; 0 <= --e && d.item(e) !== this;) {
      }

      return -1 < e;
    });
    V && (W.prototype[V] = "FormData");

    if (R) {
      var X = P.XMLHttpRequest.prototype.setRequestHeader;

      P.XMLHttpRequest.prototype.setRequestHeader = function (d, e) {
        X.call(this, d, e);
        "content-type" === d.toLowerCase() && (this.s = !0);
      };

      P.XMLHttpRequest.prototype.send = function (d) {
        d instanceof W ? (d = d._blob(), this.s || this.setRequestHeader("Content-Type", d.type), R.call(this, d)) : R.call(this, d);
      };
    }

    S && (P.fetch = function (d, e) {
      e && e.body && e.body instanceof W && (e.body = e.body._blob());
      return S.call(this, d, e);
    });
    T && (P.navigator.sendBeacon = function (d, e) {
      e instanceof W && (e = e._asNative());
      return T.call(this, d, e);
    });
    P.FormData = W;
  }
})();

var CART = scriptsConfig.SELECTORS.CART;
/**
 * Build a payload object of cart items for creating a checkout
 * @param {Object} cartData - A Shopify cart fetched from the `/cart.js` endpoint
 * @returns {Object[]} - Line item cart data in the format needed to create a checkout
 */

var transformCartData = function transformCartData(cartData) {
  return cartData.items.map(function (item) {
    return {
      quantity: item.quantity,
      variantId: btoa("gid://shopify/ProductVariant/" + item.variant_id)
    };
  });
};
/**
 * Add items to an object for the GraphQL query
 * @param {Object[]} items - Line items in the format needed to pass to the GraphQL Storefront API
 * @returns {Object} - An object with items as the property `lineItems` in a new object
 */


var makeGraphQLCheckoutPayload = function makeGraphQLCheckoutPayload(items) {
  return {
    lineItems: items
  };
};
/**
 * Check a fetch response and throw if needed
 * @param {Object} response - A fetch response object
 * @returns {Object} - The same response
 * @throws {Object} - An error object containing the response's statusText
 */


var handleFetchError = function handleFetchError(response) {
  if (!response.ok) {
    throw new Error(response.statusText);
  }

  return response;
};
/**
 * Hijack submissions of Shopify cart forms to create a custom checkout.
 * This allows multiple devices using persistent cart to reach checkout. For whatever reason,
 * while persistent cart is active, trying to checkout on more than one device
 * using the standard form submission kicks the user back to the cart page.
 * @param {Object} event - The Event passed into this handler, triggered by an event listener on the `submit` event
 */


var customCheckoutCartSubmitHandler = function customCheckoutCartSubmitHandler(event) {
  event.preventDefault();
  event.stopPropagation();
  var updateInputs = this.querySelectorAll('[name="updates[]"]'); // Create an array from the updates inputs

  var inputsArr = _toConsumableArray(updateInputs); // Filter out inputs whose value is 0


  var filteredInputs = inputsArr.filter(function (input) {
    return parseInt(input.value, 10) > 0;
  }); // If all inputs are set to 0, just abandon the handler and reload the page to refresh with no cart

  if (filteredInputs.length === 0) {
    window.location.reload();
    return false;
  } // Create a new form from inputs with quantity greater than 0


  var postForm = document.createElement('form');
  filteredInputs.forEach(function (input) {
    return postForm.appendChild(input.cloneNode());
  }); // Fetch a cart from Shopify

  fetch('/cart', {
    method: 'POST',
    body: new FormData(postForm)
  }).then(handleFetchError).then(function (res) {
    return res.json();
  }) // Transform cart data to a format that will work as a payload for the Storefront GraphQL API
  .then(transformCartData).then(makeGraphQLCheckoutPayload).then(createCheckout).then(function (res) {
    /**
     * Combine error messages and throw error if there's no checkout with a
     * `webURL` at this point
     */

    if (!res.checkout || !res.checkout.webUrl) {
      var errors = res.checkoutUserErrors;
      var messages = errors ? errors.reduce(function (acc, curr) {
        return acc + ", " + curr.message;
      }, '') : '';
      throw new Error("Error attempting to create custom checkout \uD83D\uDED2. " + messages);
    }
    /**
     * If the createCheckout method returns a checkout webURL, set it as the
     * new location, and add a query-string flag to indicate that it was
     * created using the Storefront API (for any checks within the checkout
     * flow).
     * @TODO - Decide whether the actual checkout id should be passed in some
     * way. Is it a risk to pass in the URL? Is it needed (it would be needed
     * to query the Storefront API again and verify a URL match within checkout)
     */


    window.location.assign(res.checkout.webUrl + "&" + encodeURIComponent(IS_CUSTOM_CHECKOUT) + "=true");
  }).catch(function (error) {
    console.error(error); // Reload the page in order to try to resolve issues with the last payload

    /**
     * @TODO - Look at rebuilding the cart here (and/or automatic retries).
     * Rebuilding would involve using the methods in PC to hydrate a new cart
     * (with a different token)
     */

    window.location.reload();
  });
};
/**
 * Initialize our custom checkout workaround for persistent cart.
 * Hijacks the standard cart form submission and runs a series of queries
 * to generate and transition to a new checkout URL.
 * Delegate submit event handling from any cart form to the document,
 * which is listening for all submit events.
 * In this way, the AJAX add-to-cart checkout form submit will be handled
 * even though it is not in the DOM on page load
 */


var customCheckoutInit = function customCheckoutInit() {
  document.addEventListener('submit', function (e) {
    // Loop parent nodes from the target to the delegated node
    for (var target = e.target; target && target !== this;
    /**
     * @todo Resolve TSLint issues
     * TSLint problems here. Attempted to cast event.target to HTMLElement,
     * but further issues with comparing current element to Document, so
     * adding ts-ignore to lines in this function, which is known to work
     */
    // @ts-ignore
    target = target.parentNode) {
      // @ts-ignore
      if (target.matches(CART)) {
        customCheckoutCartSubmitHandler.call(target, e);
        break;
      }
    }
  });
};

/**
 * Checks whether the value passed in has a property message,
 * returns either the original value or the value of the `.message`
 * property, if it exists
 * @param {Object|string} error - An error object or string
 * @returns {string} An error messsage
 */
var getErrorMessage = function getErrorMessage(error) {
  return typeof error.message === 'string' ? error.message : error;
};

// @ts-check

/**
 * Takes an array of parameters, each of which should be passed into a
 * Promise-returning function. The functions will be run sequentially, after
 * the previous one has resolved. Any rejection will short-circuit the chain.
 * @template InputType
 * @template OutputType
 * @param {InputType[]} array - An array of parameters, any kind, to pass
 * into the Promise-returning function defined in the 2nd parameter
 * @param {function(InputType):Promise<OutputType>} fn - Any Promise-returning function
 * @returns {Promise<OutputType[]>} - A Promise for the array of the results from the
 * chained Promise calls
 */
var chainPromises = function chainPromises(array, fn) {
  return array.reduce(function (p, item) {
    return p.then(function (prevArray) {
      return fn(item).then(function (data) {
        return prevArray.concat(data);
      });
    });
  }, Promise.resolve([]));
};

// @ts-check
var _pcConfig$SHOPIFY_API = config.SHOPIFY_API,
    GET_CART = _pcConfig$SHOPIFY_API.GET_CART,
    UPDATE_CART = _pcConfig$SHOPIFY_API.UPDATE_CART,
    ADD_TO_CART = _pcConfig$SHOPIFY_API.ADD_TO_CART;
var _scriptsConfig$SELECT = scriptsConfig.SELECTORS,
    CART_COUNT = _scriptsConfig$SELECT.CART_COUNT,
    CUSTOMER_ID = _scriptsConfig$SELECT.CUSTOMER_ID;
var shopifyPostOptions = {
  headers: {
    'Content-Type': 'application/json',
    pragma: 'no-cache',
    'cache-control': 'no-cache'
  },
  method: 'POST'
};
/**
 * Update the UI and storage, return the cart
 * @param {Cart} cart - A Shopify cart object
 * @returns {Cart} cart - the same cart
 */

var finalCartUpdates = function finalCartUpdates(cart) {
  if (!cart) {
    throw new Error('Cart not passed to handler for updating UI.');
  } // @TODO - Is this necessary. Do we actually want this to be ephemeral and go away?


  setStoredShopifyCart(cart); // Update the UI with the new count

  updateCartUI(cart.item_count);
  return cart;
};
/**
 * Update a customer in the DB with a rehydrated cart from Shopify
 * Should only be called in case of cartID/token expiration
 * At this point, our master cartID was nullified, and webhooks
 * need to look for the customer with this new cart's token / cartID
 * @param {Cart} cart - The (locally stored) Shopify cart object
 * @returns {Promise<Cart>} The cart belonging to the returned, updated customer object
 */


var updateDBCustomer = function updateDBCustomer(cart) {
  if (cart === void 0) {
    cart = getStoredShopifyCart();
  }

  // Need to update the customer in the DB only if we had a Shopify expiration event
  return createOrUpdateCustomer({
    customerID: cache.customer.customerID,
    cart: cart
  }).then(function (updatedCustomer) {
    return updatedCustomer.cart;
  });
};
/**
 * Handle errors thrown by calls to the Shopify AJAX API for cart endpoints
 * @param {Response} shopifyResponse - Response from a call to a Shopify
 * AJAX API cart endpoint
 * @returns {Promise<Object>} - Dependent on the calling function
 */


var parseShopifyCartResponse = function parseShopifyCartResponse(shopifyResponse) {
  return new Promise(function ($return, $error) {
    var responseObj;
    return Promise.resolve(shopifyResponse.json()).then(function ($await_2) {
      try {
        responseObj = $await_2;

        if (shopifyResponse.ok) {
          return $return(responseObj);
        }

        if (responseObj.description && responseObj.description.toLowerCase() === 'cannot find variant') {
          return $error(new Error('A product in the cart is invalid'));
        }

        return $error(new Error("Attempt to update or rebuild cart failed with error: " + responseObj.message));
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
};
/**
 * Add an item to a Shopify cart using the Ajax API
 * Never rejects or throws, just returns `null` if the item cannot be added
 * to the cart (suspected to be the result of trying to add a now-invalid
 * product variant)
 * @param {Object} item
 * @param {string} item.id
 * @param {string} item.quantity
 * @returns {Promise<Item|null>} - A product variant object (result of a
 * successful addition) or null
 */


var addToCart = function addToCart(_ref) {
  var id = _ref.id,
      quantity = _ref.quantity;
  var updateOptions = Object.assign({}, shopifyPostOptions, {
    body: JSON.stringify({
      id: id,
      quantity: quantity
    })
  });
  /**
   * Call fetch with the above config.
   * Return `null` for any failed 'add' - Likely cause is an invalid product
   * variant, and it will just not get re-added to the Shopify cart
   */

  return fetch(ADD_TO_CART, updateOptions).then(parseShopifyCartResponse).catch(function () {
    return null;
  });
};
/**
 * Attempt to rebuild the Shopify cart item-by-item by using the `/cart/add.js`
 * endpoint (if a call to `/cart/update.js` has failed)
 * @param {Object} reconciledCarts
 * @returns {Promise<Cart>} - A Shopify cart
 */


var rebuildCart = function rebuildCart(reconciledCarts) {
  var items = Object.keys(reconciledCarts);
  return chainPromises(items.map(function (item) {
    return {
      id: item,
      quantity: reconciledCarts[item]
    };
  }), addToCart).then(function (validatedItems) {
    return fetchShopifyCart();
  });
};
/**
 * Call to update the Shopify cart using the `/cart/update.js` endpoint
 * @param {Object} reconciledCarts
 * @returns {Promise<Cart|null>} - A Shopify cart
 */


var updateCart = function updateCart(reconciledCarts) {
  var updateOptions = Object.assign({}, shopifyPostOptions, {
    body: JSON.stringify({
      updates: reconciledCarts
    })
  }); // Call fetch with the above config

  return fetch(UPDATE_CART, updateOptions).then(parseShopifyCartResponse);
};
/**
 * Use a reconciled cart object as payload to update the Shopify cart
 * This is considered "rehydrating" if the previously used cartID/token was
 * found to be expired by Shopify
 * @param {Object} reconciledCarts - An object of line_item objects to use to
 * update the cart
 * @returns {Promise<Cart>} - The updated Shopify cart
 */


var modifyShopifyCart = function modifyShopifyCart(reconciledCarts) {
  if (reconciledCarts === void 0) {
    reconciledCarts = null;
  }

  if (!reconciledCarts) {
    throw new Error('modifyShopifyCart was called without a payload.');
  }
  var newCartID = cache.customerCartExpired ? cache.masterShopifyCart.token : cache.customer.cartID;

  if (!newCartID) {
    throw new Error("Before updating the Shopify cart, there is no token to set.");
  }
  /**
   * If the `cache.customerCartExpired` boolean is `true`, update the cart cookie
   */


  if (cache.customerCartExpired) {
    setCartCookie(newCartID);
  }
  /**
   * Now call "/cart/update.js" (a POST request)
   * to the Shopify API to update the cart in their DB
   */


  return updateCart(reconciledCarts).catch(function (error) {
    console.error('/cart/update.js returned with error', error);
    /**
     * If an error was thrown attempting to use `/cart/update.js`, now try
     * to rebuild the cart using sequential `/cart/add.js` requests
     */

    return rebuildCart(reconciledCarts);
  }).then(function (updatedCart) {
    if (updatedCart && 'item_count' in updatedCart) {

      setStoredShopifyCart(updatedCart);
      return updatedCart;
    }

    throw new Error("No cart returned after attempting to update or rebuild using token " + newCartID + (reconciledCarts ? ", with reconciled carts: " + reconciledCarts : '') + ".");
  });
};
/**
 * Reconcile two carts, if needed
 * @returns {Object} An object where the key/value pairs are set in
 * key/value pairs: {variant_id: quantity}
 */


var reconcileCarts = function reconcileCarts() {
  /**
   * If we're here, we already know that the existing cart from page load
   * has a different token value than the customer's cartID in the DB
   * We need to reconcile: 1) The cart from page load, and 2) if we've detected
   * that Shopify has expired an existing cart, the DB customer.cart, otherwise
   * the master Shopify cart
   */
  return cartReconciler(
  /**
   * NOTE - Previously, the logic for the first parameter, in the event
   * of a cart expiration event, was to set it to `null`. This resulted in
   * existing items in cart being thrown away instead of reconciled.
   * Changing to always pass in the cart from page load: `getStoredShopifyCart()`
   */
  getStoredShopifyCart(),
  /**
   * NB - This is the only place in which cart contents from the DB can be used
   * for updating the cart, due to a Shopify expiration event
   */
  cache.customerCartExpired ? cache.customer.cart : cache.masterShopifyCart);
};
/**
 * Check whether carts need reconciliation (Shopify and customer's DB cart ID
 * do not match)
 * Carts should be reconciled if 1) There were items in the cart on load,
 * 2) the cart ID on load doesn't match the customer's cartID in the DB, and
 * 3) the user wasn't logged in on last load (reconciliation only needs to
 * happen directly after login), or
 * 4) Shopify has expired our existing cart from the DB
 * @returns {boolean} - Should reconcileCarts be run?
 */


var shouldReconcileCarts = function shouldReconcileCarts() {
  var existingCustomer = cache.customer;
  var shopifyCart = getStoredShopifyCart();
  /*
   * Return true if we've detected that Shopify has expired our cart
   */

  if (cache.customerCartExpired) {
    return true;
  }
  /**
   * Return false if there were no items in the cart
   * or the customer was already logged in on previous page load
   */


  if (!shopifyCart || getWasLoggedIn()) {
    return false;
  }
  /**
   * Errors if there is no existing customer in the DB at this point or no
   * `shopifyCart.token`
   */


  if (!existingCustomer || !shopifyCart.token) {
    throw new Error("Checking whether carts should be reconciled failed because\n      " + cache.customerID + " or a Shopify cart ID could not be found.");
  } // Check existingCustomer.cartID against shopifyCart token value


  var cartIDsMismatch = existingCustomer && existingCustomer.cartID && existingCustomer.cartID !== shopifyCart.token;
  return cartIDsMismatch;
};
/**
 * Call out to create a new customer with cart if the cart has items (was set) and isn't already in our DB
 * @param {Cart} [shopifyCart] - A locally stored Shopify cart object
 * @returns {boolean} - Whether or not to continue on with the Promise chain for other PC tasks
 */


var assignCartIfNew = function assignCartIfNew(shopifyCart) {
  if (shopifyCart === void 0) {
    shopifyCart = getStoredShopifyCart();
  }

  var existingCustomer = cache.customer;
  var setNewCustomerOrCart = shopifyCart && (!existingCustomer || existingCustomer && !existingCustomer.cartID);
  cache.setNewCustomerOrCart = setNewCustomerOrCart;

  if (setNewCustomerOrCart) {
    return createOrUpdateCustomer({
      customerID: cache.customerID,
      cart: shopifyCart
    }).then(function (customer) {
      // Update the in-memory store of the new or updated customer
      cache.customer = customer;
      existingCustomer = customer;
      return false;
    });
  }
  /**
   * At this point, we know that we didn't create or update a customer
   * If a customer exists and has a cartID, continue
   */


  if (existingCustomer && existingCustomer.cartID) {

    return true;
  }
  /**
   * There's nothing more to do if the cart is empty and there isn't already a customer in the DB
   * or there is a customer with no cart
   * There may be a customer with no cart if a customer is in our DB without a cart
   * and this is a page load event with 0 items in the cart (we do not use an empty cart to update or create
   * a customer in the DB - in the event that the Shopify `cart.token` changes again)
   */


  if (!shopifyCart && !existingCustomer || existingCustomer && !existingCustomer.cartID) {
    return false;
  } // If none of the above conditions passes, there's a problem


  throw new Error("Customer " + cache.customerID + " should already have been set in the database, but has not been.");
};
/**
 * Fetch a Shopify cart, with or without first setting the cartID (i.e., the "page-load" vs the "master" carts)
 * @param {string} [cartID] - A cart ID (aka, token) to be used to set the cart cookie
 * before making the GET request
 * @returns {Promise<Cart>} A Shopify cart
 */


var fetchShopifyCart = function fetchShopifyCart(cartID) {
  if (cartID) {
    setCartCookie(cartID);
  }

  return fetch(GET_CART, {
    headers: {
      pragma: 'no-cache',
      'cache-control': 'no-cache'
    }
  }).then(function (res) {
    return res.json();
  }).then(function (cart) {
    if (!cart) {
      throw new Error("Could not fetch a cart from Shopify with cartID " + (cartID || getCartCookie) + ".");
    }

    return cart;
  });
};
/**
 * Get a Shopify cart on page load from the Storefront AJAX API
 * Called without first setting a cart cookie, unlike the "master" cart
 * @returns {Promise<Cart|null>} - A Shopify cart or null if there is nothing in the cart on page load
 */


var fetchPageLoadShopifyCart = function fetchPageLoadShopifyCart() {
  return cache.currentCartCount > 0 ? fetchShopifyCart() : Promise.resolve(null);
};
/**
 * Save off a Shopify cart locally, for reference
 * @param {Cart} [cart] - The Shopify cart object
 * @returns {Cart|null} cart - A cart if one was stored, null if one was not stored
 */


var persistPageLoadShopifyCart = function persistPageLoadShopifyCart(cart) {
  // Persist the Shopify cart locally, for the moment, then return it
  // If a cart is not passed, will remove stored cart from localStorage, otherwise set it
  if (cart) {
    setStoredShopifyCart(cart);
  } else {
    removeStoredShopifyCart();
  }

  return getStoredShopifyCart();
};
/**
 * Save the boolean flagging whether a customer's cart was expired by Shopify
 * @param {boolean} expired - Whether or not Shopify has expired the cart we've saved in the DB
 * @returns {boolean} Returns the `expired` argument
 */


var persistCustomerCartExpired = function persistCustomerCartExpired(expired) {
  cache.customerCartExpired = expired;
  return expired;
};
/**
 * Check whether Shopify has expired the cart associated with the cartID associated with
 * a customer record in the database
 * @param {Cart} [masterShopifyCart] - The cart retrieved from Shopify after setting with the customer.cartID from the DB
 * @returns {boolean} -  Whether or not Shopify has expired the cart (should rarely be true, usually false)
 */


var isCustomerCartExpired = function isCustomerCartExpired(masterShopifyCart) {
  if (masterShopifyCart === void 0) {
    masterShopifyCart = cache.masterShopifyCart;
  }

  return masterShopifyCart && masterShopifyCart.token !== cache.customer.cartID;
};
/**
 * Get a "master" Shopify cart by passing in the customer.cartID from the database
 * This cartID will be used to set the cart cookie before GETting a cart from the AJAX API
 * Referring to this cart as the "master"
 * @returns {Promise<Cart>} - A Shopify cart
 */


var fetchMasterShopifyCart = function fetchMasterShopifyCart() {
  /**
   * Pass the cart cookie to make sure we're getting the master cart.
   * `fetchShopifyCart` will use the passed cartID to set the cart cookie
   * before making a GET request to the Shopify AJAX API
   */
  return fetchShopifyCart(cache.customer.cartID);
};
/**
 * Persist the "master" Shopify cart, retrieved by first setting the cart cookie
 * to the value of the customer.cartID from the DB
 * @param {Cart} cart - The cart object returned from Shopify
 * @returns {Cart} The same cart object
 */


var persistMasterShopifyCart = function persistMasterShopifyCart(cart) {
  cache.masterShopifyCart = cart;
  return cart;
};
/**
 * Check whether the token of the cart fetched on page load matches the customer's cartID
 * No need to overwrite the cookie or many other things in this flow if they match
 * @returns {boolean} - Should we fetch the "master" cart?
 */


var shouldMasterCartBeFetched = function shouldMasterCartBeFetched() {
  var pageLoadShopifyCart = getStoredShopifyCart();
  var pageLoadToken = pageLoadShopifyCart && pageLoadShopifyCart.token ? pageLoadShopifyCart.token : null;
  var customerCartID = cache.customer && cache.customer.cartID ? cache.customer.cartID : null;

  if (pageLoadToken === customerCartID) {
    return false;
  }

  return true;
};
/**
 * Assign a customer object DB to a global customer object for further reference, return
 * @params {Object|null} retrievedCustomer - The value of a customer retrieved from the custom DB
 * @returns {Object|null} - The same value
 */


var persistCustomer = function persistCustomer(retrievedCustomer) {
  // Persist the customer locally, for the moment (could be null)
  cache.customer = retrievedCustomer;
  return retrievedCustomer;
};
/**
 * The end of the PC Promise chain, called if it's determined that carts need
 * reconciling and Shopify and/or the DB, and the UI, need updating
 * @param {Object} reconciledCarts - The object used to call to the Shopify AJAX API to update a cart
 * @returns {Promise<Cart>} - The Shopify cart after the PC flow has finished completely
 */


var handleAllNecessaryUpdates = function handleAllNecessaryUpdates(reconciledCarts) {
  return modifyShopifyCart(reconciledCarts).then(function (cart) {
    return cache.customerCartExpired ? updateDBCustomer(cart) : cart;
  }).then(finalCartUpdates);
};
/**
 * Determine whether to fetch a master Shopify cart (using the customer's cartID)
 * If needed, fetch and persist, otherwise, return the cart from page load
 * @returns {Promise<Cart>} - A Shopify cart
 */


var getCartForUpdates = function getCartForUpdates() {
  return shouldMasterCartBeFetched() ? fetchMasterShopifyCart().then(persistMasterShopifyCart) : Promise.resolve(getStoredShopifyCart());
};
/**
 * Kick off a new portion of the Promise chain by getting the "master" Shopify
 * cart (which will use the customer's cartID from the DB as the cart cookie value)
 * Will check and persist the master cart and a boolean flagging whether Shopify has expired
 * the existing customer.cartID. Finally, will determine whether to reconcile carts
 * @returns {*} - A call to continue cart reconciliation and update tasks or to end by storing the master
 * cart and update the UI with its item_count
 */


var handleReconciliationAndExpiration = function handleReconciliationAndExpiration() {
  var cartToUseForUpdates;
  return getCartForUpdates().then(function (cart) {
    cartToUseForUpdates = cart;
    return isCustomerCartExpired(cart);
  }).then(persistCustomerCartExpired).then(shouldReconcileCarts).then(function (shouldReconcile) {
    if (shouldReconcile) {
      var reconciledCarts = reconcileCarts();
      return handleAllNecessaryUpdates(reconciledCarts);
    }

    return finalCartUpdates(cartToUseForUpdates);
  });
};
/**
 * Call a chain of functions to create or update a customer in our DB,
 * get and locally save items from a Shopify cart (if needed), and update
 * Shopify (if needed)
 * @param {Customer} customer - A customer retrieved from our DB
 */


var pcInit = function pcInit(customer) {
  persistCustomer(customer);
  return fetchPageLoadShopifyCart().then(persistPageLoadShopifyCart).then(assignCartIfNew).then(function (shouldHandleReconciliationAndExpiration) {
    return shouldHandleReconciliationAndExpiration ? handleReconciliationAndExpiration() : "" + (cache.setNewCustomerOrCart ? "A customer was just created or updated: ' " + cache.customer.customerID : "There's no saved customer, or the saved customer has no cart, and the Shopify cart is empty, so ending");
  });
};
/**
 * If there is a customerID in the template on page load, an attempt is made to fetch
 * the customer from the DB, which will return a customer Object or null (no such customer in the DB).
 * - Kicks off PC with this value. Also binds the Ajax Handler for add-to-cart actions.
 * - Runs a Promise chain for enabling persistent cart, catches errors.
 * - Sets a flag to indicate the customer was logged in at the end of running.
 * @param {Customer|null} customer - The customer value retrieved from the application DB (or null if no customer was yet in the DB)
 */


var initWithCustomer = function initWithCustomer(customer) {

  logoutHandlerInit(); // Initialize the persistent cart flow

  pcInit(customer).then(function (response) {
    if (response && response.error) {
      throw new Error(getErrorMessage(response.error));
    }
    /**
     * Set a flag showing that the user was logged in as of this time.
     * Do this only in the "finally" block of when all of the PC flow is complete
     * This flag will be unset as soon as the page loads without a customerID
     */


    setWasLoggedIn();
  }) // Catch all errors from ensuing calls
  .catch(function (error) {
    // @TODO - Promise.finally might need shimming. Instead, just call setLoggedIn on both success and failure
    setWasLoggedIn();
    console.error('Persistent cart errors or messages: ', getErrorMessage(error));
  }); // Pass PC client initialization as a callback to the add-to-cart module

  onCartAjaxUpdated(function (quantity) {
    /**
     * First update the cart quantity to add to what was in the template at page load
     */
    cache.currentCartCount += quantity; // Now call the application init function

    pcInit(customer);
  });
};
/**
 * If there is no customerID in the template on page load, run cleanup
 * - If and only if the user transitioned from a logged-in state:
 * - Clears cart cookies
 * - Updates the UI with cart item count 0
 * Also
 * - Removes logged in flag that was set the last time the page loaded
 * with a customer ID in the template
 * - Removes any saved Shopify cart in storage
 */


var initWithoutCustomer = function initWithoutCustomer() {
  /**
   * If a flag was previously set that the user was logged in and now they are not
   * remove the cart cookie, and also update the cart item count to 0.
   * Cart cookie reset is also bound to click on the logout button, but testing
   * indicated that a fallback might be necessary.
   */
  if (getWasLoggedIn()) {
    removeCartCookie();
    updateCartUI(0);
  }
  /**
   * Set a flag showing that the user was not logged in as of this time.
   * Do this only when there is no customerID in the template
   * This flag will be set after page loads without a customerID and
   * when the PC flow is complete
   */


  removeWasLoggedIn();
  /**
   * Remove any locally saved cart information
   */

  removeStoredShopifyCart();
};
/**
 * Kick off persistent cart, called on DOM Content Loaded
 * Will check for the following, and not proceed if conditions aren't met
 * 1) A customer exists
 * 2) A query for the customer can be made to the DB successfully - a health check of the PC app
 * 2) localStorage is supported and usable - TBD whether this is necessary
 * 3) Cookies are enabled/usable
 * Catches and logs for the chain of request-making functions it calls.
 * @param {string} customerID
 */


var pcCheckInit = function pcCheckInit(customerID) {
  /** @type HTMLInputElement */
  var cartCountEl = document.querySelector(CART_COUNT);
  /**
   * The value of currentCartCount may be "0" unless there are items in the
   * cart at the time of login. PC un-sets the cart cookie on logout, and it
   * will not be set again unless 1 or more items are added to the cart
   */

  cache.currentCartCount = parseInt(cartCountEl.value, 10);

  cache.customerID = customerID; // Test for a customer plus localStorage and cookie support (enabled), or do not proceed

  if (localStorageAvailable && cookiesAvailable) {
    if (cache.customerID) {
      getCustomer(cache.customerID).then(function (customerResponse) {
        /**
         * Assuming
         * - The Storefront API was successfully queried and
         * - Either there's no customer in our DB yet or there is and Mongo
         *   did not return an error
         * Proceed
         */
        if (!customerResponse || typeof customerResponse === 'object' && !('error' in customerResponse)) {
          initWithCustomer(customerResponse);
          return;
        }

        if ('error' in customerResponse) {
          throw new Error(customerResponse.error);
        }
      }).catch(function (error) {
        console.error('Persistent cart cannot be initialized', error);
        removeStoredShopifyCart();
      });
    } else {
      initWithoutCustomer();
    }
  }
};
/**
 * Cleanup actions to take on initialzation failures, depending on whether or
 * not a customer is logged in
 * @param {string} customerID
 */


var initCleanup = function initCleanup(customerID) {
  if (customerID) {
    removeStoredShopifyCart();
  } else {
    initWithoutCustomer();
  }
};
/**
 * Initialize on DOM Content Loaded:
 * - Run a health-check request to the Shopify Storefront API, and attempt to
 *   persist this value to storage for future checks (with an expiration).
 *   Conditionally runs cleanup if `sessionStorage` is not available
 * - If that succeeds:
 *     - Initialize custom checkouts (auth and guest users, so
 *       with or without PC running)
 *     - Kick off the PC check and initialize flow (which will run PC for auth
 *       users, only, given other criteria are met)
 * - If the query to the Storefront API fails
 *     - Do not initialize custom checkouts
 *     - Run a cleanup initialization for PC (same operations as happen when a
 *       user logs out)
 */


document.addEventListener('DOMContentLoaded', function () {
  return new Promise(function ($return, $error) {
    var cidEl, customerID, storefrontAPIWorks;
    cidEl = document.querySelector(CUSTOMER_ID);
    customerID = cidEl && cidEl.value ? cidEl.value : null;

    if (sessionStorageAvailable) {
      return Promise.resolve(persistedStorefrontAPITest()).then(function ($await_3) {
        try {
          storefrontAPIWorks = $await_3;

          if (storefrontAPIWorks) {
            if (DEBUG) console.debug('Shopify  Storefront API test succeeded'); // Initialize custom checkout for all customers: Favro DEC-3130

            if (undefined !== 'true') {
              customCheckoutInit();
            }

            pcCheckInit(customerID);
          } else {
            console.error('Shopify  Storefront API test failed');
            initCleanup(customerID);
          }

          return $If_1.call(this);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    } else {
      console.error("Session storage test failed, cannot persist Storefront API\n    health check results");
      initCleanup(customerID);
      return $If_1.call(this);
    }

    function $If_1() {
      return $return();
    }
  });
});
