import { V as Vue } from './built-vue.esm-661ab646.js';
import { f as fetchStores } from './built-fetch-stores-13903880.js';
import { _ as _toConsumableArray } from './built-toConsumableArray-0fbe23f7.js';
import { c as setObjectInLocalStorage, b as getObjectFromLocalStorage, r as removeItemFromLocalStorage } from './built-storage-f11703b1.js';

const getReverseGeocode = (function (latLng) {
  return new Promise(function (resolve, reject) {
    var geocoder = new google.maps.Geocoder();
    geocoder.geocode({
      latLng: latLng
    }, function (results, status) {
      if (status === 'OK') {
        resolve(results[0]);
      } else {
        reject(new Error("Could not find the reverse geocode of: " + latLng));
      }
    });
  });
});

// @ts-check
/**
 * @typedef {Object} LocationInfo
 * @property {string} zip_code - A user's Zip Code
 * @property {string} city - A user's city name
 * @property {string} region_code - A user's state abbr, usually
 */

/**
 * @typedef {Object} PositionObject
 * @property {Object} coords
 * @property {number} coords.latitude
 * @property {number} coords.longitude
 */

/**
 * Get a user's location via IP, using ipstack
 * @see https://apilayer.com
 * @returns {Promise<LocationInfo>}
 *
 * @TODO - This function was originally included for Store Finder and was
 * repurposed for use with Product Fulfillment Options, via the function
 * `fetchUserLocationData`.
 * @see //scripts/product-page/fulfillment-options/api.js
 *
 * The shape of typedef `LocationInfo` (`fetchUserLocation`) and
 * typedef `UserLocationData` (`fetchUserLocationData`) is nearly identical.
 * Here, it is what is returned by ipstack. Elsewhere, we return the same
 * shape from reverse geocoding, to match.
 *
 * If we can modify `fetchUserLocation` to return the same shape as we consume
 * in the ui (camelCased properties, renamed as needed), and use throughout the
 * code, we can potentially reduce the number of functions needed and clean
 * things up.
 *
 * It was decided to not do this during review of PRs related to
 * Product Fulfillment, since it could result in time lost and regressions in
 * Store Finder, but should be considered a possible technical debt task.
 *
 * @see https://github.com/decathlon-usa/shopify-theme-decathlonusa/pull/516
 */

var fetchUserLocation = function fetchUserLocation() {
  return new Promise(function ($return, $error) {
    var url, response, json;

    var $Try_1_Catch = function (error) {
      try {
        console.error('Error getting user location by IP: ', error.message);
        throw error;
      } catch ($boundEx) {
        return $error($boundEx);
      }
    };

    try {
      url = 'https://api.ipstack.com/check?access_key=23cb2745b5ee35580d6f00373f14f868&legacy=1';
      return Promise.resolve(fetch(url)).then(function ($await_6) {
        try {
          response = $await_6;
          return Promise.resolve(response.json()).then(function ($await_7) {
            try {
              json = $await_7;
              return $return(json);
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }, $Try_1_Catch);
        } catch ($boundEx) {
          return $Try_1_Catch($boundEx);
        }
      }, $Try_1_Catch);
    } catch (error) {
      $Try_1_Catch(error);
    }
  });
};

var getDistanceMatrix = function getDistanceMatrix(data) {
  return new Promise(function (resolve, reject) {
    var distanceService = new google.maps.DistanceMatrixService();
    distanceService.getDistanceMatrix(data, function (response, status) {
      if (status === 'OK') {
        resolve(response);
      } else {
        reject(response);
      }
    });
  });
};

const _getDistance = (function (_ref) {
  return new Promise(function ($return, $error) {
    var origin, destinations, data, result, elements, distances;
    origin = _ref.origin, destinations = _ref.destinations;

    var $Try_1_Catch = function (error) {
      try {
        console.error(error);
        throw error;
      } catch ($boundEx) {
        return $error($boundEx);
      }
    };

    try {
      data = {
        origins: ["POSTCODE " + origin + " Australia"],
        destinations: _toConsumableArray(destinations),
        travelMode: 'DRIVING',
        unitSystem: google.maps.UnitSystem.METRIC
      };
      return Promise.resolve(getDistanceMatrix(data)).then(function ($await_2) {
        try {
          result = $await_2;
          elements = result.rows[0].elements;
          distances = elements.map(function (element) {
            return element.distance && element.distance.text;
          });
          return $return(distances.filter(function (distance) {
            return distance;
          }));
        } catch ($boundEx) {
          return $Try_1_Catch($boundEx);
        }
      }, $Try_1_Catch);
    } catch (error) {
      $Try_1_Catch(error);
    }
  });
});

const _getUserGeolocation = (function () {
  return new Promise(function (resolve, reject) {
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(resolve, reject);
    } else {
      reject(new Error('Geolocation is not supported by browser.'));
    }
  });
});

const _loadGoogleMaps = (function () {
  var API_KEY = 'AIzaSyAcTzkU5Oer4RHlNRuXvVbItDMRs14-Pcw';
  var CALLBACK_NAME = 'initMap';
  var initialized = window.google;
  var resolveInitPromise = null;
  var rejectInitPromise = null;
  var initPromise = new Promise(function (resolve, reject) {
    resolveInitPromise = resolve;
    rejectInitPromise = reject;
  }); // If Google Maps already is initialized
  // the `initPromise` should get resolved
  // eventually.

  if (initialized) return initPromise;
  initialized = true; // The callback function is called by
  // the Google Maps script if it is
  // successfully loaded.

  window[CALLBACK_NAME] = function () {
    return resolveInitPromise(window.google);
  }; // We inject a new script tag into
  // the `<head>` of our HTML to load
  // the Google Maps script.


  var script = document.createElement('script');
  script.setAttribute('async', '');
  script.setAttribute('defer', '');
  script.setAttribute('src', "https://maps.googleapis.com/maps/api/js?key=" + API_KEY + "&callback=" + CALLBACK_NAME);
  script.addEventListener('error', rejectInitPromise);
  document.querySelector('head').appendChild(script);
  return initPromise;
});

const formatStoreAddress = (function (store) {
  return store.street1 + ", " + store.city + ", " + store.state + " " + store.zip;
});

const objectToParams = (function (obj) {
  return Object.keys(obj).map(function (key) {
    return encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
  }).join('&');
});

var clear = "\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"12\" viewBox=\"0 0 12 12\">\n  <g fill=\"none\">\n    <g fill=\"#ACB3B8\">\n      <path d=\"M11.7 1.7C11.9 1.5 12 1.3 12 1 12 0.7 11.9 0.5 11.7 0.3 11.5 0.1 11.3 0 11 0 10.7 0 10.5 0.1 10.3 0.3L6 4.6 1.7 0.3C1.5 0.1 1.3 0 1 0 0.7 0 0.5 0.1 0.3 0.3 0.1 0.5 0 0.7 0 1 0 1.3 0.1 1.5 0.3 1.7L4.6 6 0.3 10.3C0.1 10.5 0 10.7 0 11 0 11.3 0.1 11.5 0.3 11.7 0.5 11.9 0.7 12 1 12 1.3 12 1.5 11.9 1.7 11.7L6 7.4 10.3 11.7C10.5 11.9 10.7 12 11 12 11.3 12 11.5 11.9 11.7 11.7 11.9 11.5 12 11.3 12 11 12 10.7 11.9 10.5 11.7 10.3L7.4 6 11.7 1.7Z\"></path>\n    </g>\n  </g>\n</svg>\n";
var checkmark = "\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10.3\" height=\"8\" viewBox=\"8.9 0.3 10.3 8\" class='de-Icon'>\n  <path d=\"M12.6 8.1L8.9 4.3l1-1.1 2.7 2.7L18.1.5l1 1z\"></path>\n</svg>\n";
var geolocation = "\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" class='de-Icon'>\n  <path d=\"M19.2 9.4L17.2 9.4C16.9 5.9 14.1 3.1 10.6 2.8L10.6 0.8C10.6 0.5 10.3 0.2 10 0.2 9.7 0.2 9.4 0.5 9.4 0.8L9.4 2.8C5.9 3.1 3.1 5.9 2.8 9.4L0.8 9.4C0.5 9.4 0.2 9.7 0.2 10 0.2 10.3 0.5 10.6 0.8 10.6L2.8 10.6C3.1 14.1 5.9 16.9 9.4 17.2L9.4 19.2C9.4 19.5 9.7 19.8 10 19.8 10.3 19.8 10.6 19.5 10.6 19.2L10.6 17.2C14.1 16.9 16.9 14.1 17.2 10.6L19.2 10.6C19.5 10.6 19.8 10.3 19.8 10 19.8 9.7 19.5 9.4 19.2 9.4ZM10.1 16L10 16 9.9 16C6.7 16 4 13.3 4 10.1 4 10 4 10 4 9.9 4 6.7 6.7 4 9.9 4L10 4 10.1 4C13.3 4 16 6.7 16 9.9 16 10 16 10 16 10.1 16 13.3 13.3 16 10.1 16Z\"></path>\n  <path d=\"M10 7.1C8.4 7.1 7.1 8.4 7.1 10 7.1 11.6 8.4 12.9 10 12.9 11.6 12.9 12.9 11.6 12.9 10 12.9 8.4 11.6 7.1 10 7.1ZM10 11.7C9.1 11.7 8.3 10.9 8.3 10 8.3 9.1 9.1 8.3 10 8.3 10.9 8.3 11.7 9.1 11.7 10 11.7 10.9 10.9 11.7 10 11.7Z\"></path>\n</svg>\n";
var information = "\n<svg height=\"17\" viewBox=\"0 0 18 18\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g transform=\"translate(-304.000000, -33.000000)\" fill=\"#ACB3B8\" fill-rule=\"nonzero\">\n      <g transform=\"translate(304.000000, 33.000000)\">\n        <g>\n          <path d=\"M9.0032625,18 C4.03270023,18.0018015 0.00180290276,13.9738252 1.18279906e-06,9.00326289 C-0.00180053716,4.03270063 4.02617563,0.0018031202 8.99673789,1.18251325e-06 C13.9673002,-0.00180075517 17.9981978,4.02617523 18,8.9967375 L18,9.0032625 C17.9928332,13.9690518 13.9690518,17.9928332 9.0032625,18 Z M9.0032625,1.3080825 C4.7533325,1.30628105 1.30662308,4.75006954 1.30482138,8.99999954 C1.30301968,13.2499295 4.74680796,16.6966392 8.99673796,16.6984411 C13.246668,16.7002431 16.6933778,13.256455 16.69518,9.006525 L16.69518,9.0032625 C16.6915893,4.75609362 13.2504295,1.31347425 9.0032625,1.3080825 Z\" id=\"Shape\"></path>\n          <g transform=\"translate(7.959405, 4.893075)\">\n            <circle cx=\"1.0438575\" cy=\"1.0438575\" r=\"1.0438575\"></circle>\n            <rect x=\"0.2316075\" y=\"2.8901775\" width=\"1.617975\" height=\"5.3269275\"></rect>\n          </g>\n        </g>\n      </g>\n    </g>\n  </g>\n</svg>\n";
var star = "\n<svg height=\"17\" viewBox=\"0 0 18 17\">\n  <g fill=\"none\">\n    <g fill=\"#ACB3B8\">\n      <path d=\"M3.9 16.5C3.4 16.4 3.1 16 3.1 15.6L3.6 10.7 0.2 7C0 6.8 0 6.5 0 6.2 0.1 6 0.4 5.8 0.6 5.7L5.7 4.6 8.3 0.4C8.4 0.1 8.7 0 9 0 9.3 0 9.5 0.1 9.7 0.4L12.3 4.6 17.4 5.7C17.6 5.8 17.9 6 18 6.2 18 6.5 18 6.8 17.8 7L14.4 10.7 14.9 15.6C14.9 15.9 14.8 16.2 14.5 16.3 14.3 16.5 14 16.5 13.7 16.4L9 14.5 4.3 16.4C4.1 16.5 4 16.5 3.9 16.5L3.9 16.5ZM5 13.9L8.7 12.5C8.9 12.4 9.1 12.4 9.3 12.5L13 13.9 12.6 10.2C12.6 10 12.7 9.8 12.8 9.7L15.4 6.9 11.5 6.1C11.3 6 11.1 5.9 11 5.7L9 2.5 7 5.7C6.8 5.9 6.7 6 6.5 6.1L2.6 6.9 5.2 9.7C5.3 9.8 5.4 10 5.4 10.2L5 13.9 5 13.9Z\"></path>\n    </g>\n  </g>\n</svg>\n";
var starSolid = "\n<svg height=\"17\" viewBox=\"0 0 20 20\">\n  <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g transform=\"translate(-2.000000, -1.000000)\" fill=\"#ACB3B8\">\n      <polygon points=\"12 1.85449219 8.53613281 7.31054687 2.3828125 8.94213867 6.08959961 13.9658203 5.68823242 20.6660156 12 18.3659668 18.3823242 20.9941406 18.3823242 13.9658203 22.0324707 8.94213867 15.8916016 7.31054687\"></polygon>\n    </g>\n  </g>\n</svg>\n";
var search = "\n<svg class=\"de-Icon\" width=\"24\" height=\"24\" viewBox=\"0 0 32 32\" role=\"presentation\">\n  <path d=\"M26.9,25.1l-5.7-5.7c0.6-0.8,1.1-1.7,1.5-2.6c0.4-1,0.5-2,0.5-3.1c0-1.3-0.2-2.5-0.7-3.6c-0.5-1.1-1.1-2.1-2-2.9\n  c-0.8-0.8-1.8-1.5-2.9-2S15.3,4.4,14,4.4c-1.3,0-2.5,0.2-3.6,0.7s-2.1,1.1-2.9,2s-1.5,1.8-2,2.9s-0.7,2.3-0.7,3.6\n  c0,1.3,0.2,2.5,0.7,3.6s1.1,2.1,2,2.9c0.8,0.8,1.8,1.5,2.9,2c1.1,0.5,2.3,0.7,3.6,0.7c0.9,0,1.8-0.1,2.7-0.4\n  c0.9-0.3,1.7-0.6,2.4-1.1l5.8,5.8c0.1,0.1,0.3,0.2,0.5,0.3c0.2,0.1,0.4,0.1,0.6,0.1c0.4,0,0.7-0.1,1-0.4c0.3-0.3,0.4-0.6,0.4-1\n  c0-0.2,0-0.4-0.1-0.6C27.1,25.4,27,25.2,26.9,25.1L26.9,25.1L26.9,25.1z M7.7,13.6c0-0.9,0.2-1.7,0.5-2.5c0.3-0.8,0.8-1.4,1.4-2\n  c0.6-0.6,1.2-1,2-1.4s1.6-0.5,2.5-0.5c0.9,0,1.7,0.2,2.5,0.5c0.8,0.3,1.4,0.8,2,1.4c0.6,0.6,1,1.2,1.4,2c0.3,0.8,0.5,1.6,0.5,2.5\n  c0,0.9-0.2,1.7-0.5,2.5c-0.3,0.8-0.8,1.4-1.4,2c-0.6,0.6-1.2,1-2,1.4c-0.8,0.3-1.6,0.5-2.5,0.5c-0.9,0-1.7-0.2-2.5-0.5\n  c-0.8-0.3-1.4-0.8-2-1.4c-0.6-0.6-1-1.2-1.4-2C7.9,15.3,7.7,14.5,7.7,13.6C7.7,13.6,7.7,13.6,7.7,13.6z\"></path>\n</svg>\n";

var searchForm = {
  inheritAttrs: false,
  props: ['search-input', 'search-input-placeholder', 'geolocation-copy'],
  template: "\n    <form\n      @submit.prevent='$emit(\"form-submit\")'\n      class='de-SingleInputForm de-u-spaceEnds06 de-StoreSearch'\n    >\n      <p class='de-u-textDarkGrasy de-u-spaceBottom06 de-u-textShrink1'>Search by city or zipcode</p>\n      <div\n        :class='{ isFocused: isFocused }'\n        class='de-u-flex de-u-bgSilver de-StoreSearch-inputWrapper'\n      >\n        <input\n          v-bind='$attrs'\n          v-on='listeners'\n          :placeholder='\"Your location: \" + searchInputPlaceholder'\n          @blur='isFocused = false'\n          @focus='isFocused = true'\n          ref='searchInput'\n          class='de-Input de-SingleInputForm-input de-u-textShrink1 de-u-bgSilver de-StoreSearch-input'\n        >\n        <a\n          v-show='searchInput.length > 0'\n          @click='clearInput'\n          :class='{ \"de-u-flex\": searchInput.length > 0 }'\n          class='de-StoreSearch-clear de-u-flexAlignItemsCenter de-u-flexJustifyCenter de-u-cursorPointer'\n        >\n          <span\n            v-html='icons.clear'\n            class='de-u-flex'\n          ></span>\n        </a>\n        <button\n          :class='{ isFocused: isFocused }'\n          class='de-StoreSearch-submit de-u-flex de-u-flexAlignItemsCenter de-u-flexJustifyCenter de-SingleInputForm-action'\n        >\n          <span\n            v-html='icons.search'\n            class='de-u-flex'\n          ></span>\n        </button>\n      </div>\n      <a\n        @click='$emit(\"get-user-geolocation\")'\n        class='de-u-flex de-u-spaceTop06 de-u-cursorPointer'\n      >\n        <span\n          v-html='icons.geolocation'\n          class='de-u-flex de-u-flexAlignItemsCenter de-u-flexJustifyCenter'\n        ></span>\n        <span\n          v-text='geolocationCopy'\n          class='de-u-spaceLeft07 de-u-textShrink1 de-u-textMedium'\n        ></span>\n      </a>\n    </form>\n ",
  data: function data() {
    return {
      input: '',
      icons: {
        clear: clear,
        geolocation: geolocation,
        search: search
      },
      isFocused: false
    };
  },
  computed: {
    listeners: function listeners() {
      var _this = this;

      return Object.assign({}, this.$listeners, {
        input: function input(event) {
          return _this.$emit('input', event.target.value);
        }
      });
    }
  },
  methods: {
    clearInput: function clearInput() {
      this.$emit('clear-search-input');
      this.$refs.searchInput.focus();
    }
  }
};

var getGeocode = function getGeocode(address) {
  return new Promise(function (resolve, reject) {
    var geocoder = new google.maps.Geocoder();
    geocoder.geocode({
      address: address,
      region: 'AU'
    }, function (results, status) {
      if (status === 'OK') {
        resolve(results[0]);
      } else {
        reject(new Error("Couldn't find the geocode of: " + address));
      }
    });
  });
};

const getGeocode$1 = (function (stores) {
  return new Promise(function ($return, $error) {
    var locationData, results;

    var $Try_1_Catch = function (error) {
      try {
        console.error(error);
        throw error;
      } catch ($boundEx) {
        return $error($boundEx);
      }
    };

    try {
      locationData = stores.map(function (store) {
        var address = formatStoreAddress(store);
        return getGeocode(address);
      });
      return Promise.resolve(Promise.all(locationData)).then(function ($await_2) {
        try {
          results = $await_2;
          return $return(results);
        } catch ($boundEx) {
          return $Try_1_Catch($boundEx);
        }
      }, $Try_1_Catch);
    } catch (error) {
      $Try_1_Catch(error);
    }
  });
});

const mapStyle = [{
  featureType: 'administrative.land_parcel',
  stylers: [{
    visibility: 'off'
  }]
}, {
  featureType: 'administrative.neighborhood',
  stylers: [{
    visibility: 'off'
  }]
}, {
  featureType: 'poi',
  stylers: [{
    visibility: 'off'
  }]
}, {
  featureType: 'poi',
  elementType: 'labels.text',
  stylers: [{
    visibility: 'off'
  }]
}, {
  featureType: 'road',
  stylers: [{
    visibility: 'simplified'
  }]
}, {
  featureType: 'road',
  elementType: 'labels',
  stylers: [{
    visibility: 'off'
  }]
}, {
  featureType: 'road.highway',
  stylers: [{
    visibility: 'simplified'
  }]
}, {
  featureType: 'water',
  stylers: [{
    visibility: 'simplified'
  }]
}, {
  featureType: 'water',
  elementType: 'labels.text',
  stylers: [{
    visibility: 'off'
  }]
}];

var map = {
  props: ['initialStores', 'isSelectedStore'],
  template: "\n    <div></div>\n  ",
  data: function data() {
    return {
      map: null,
      stores: this.initialStores,
      storeMarkers: []
    };
  },
  computed: {
    markerIcon: function markerIcon() {
      var iconConfig = {
        size: new google.maps.Size(40, 40)
      };
      var active = Object.assign({}, iconConfig, {
        url: window.mapMarkerActiveIcon
      });
      var inactive = Object.assign({}, iconConfig, {
        url: window.mapMarkerInactiveIcon
      });
      return {
        active: active,
        inactive: inactive
      };
    }
  },
  watch: {
    isSelectedStore: function isSelectedStore(store) {
      var _this = this;

      var marker = this.storeMarkers.filter(function (marker) {
        return marker.store.id === store.id;
      })[0];
      this.storeMarkers.forEach(function (m) {
        return m.setIcon(_this.markerIcon.inactive);
      });

      if (marker) {
        marker.setIcon(this.markerIcon.active);
        this.map.panTo(marker.getPosition());
      }
    }
  },
  mounted: function mounted() {
    this.initMap();
  },
  methods: {
    initMap: function initMap() {
      return new Promise(function ($return, $error) {
        var config, storeGeocodeResults;

        var $Try_1_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_1_Catch = function (error) {
          try {
            console.error(error);
            throw error;
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          config = {
            zoomControl: !('ontouchend' in document),
            mapTypeControl: false,
            scaleControl: false,
            streetViewControl: false,
            rotateControl: false,
            fullscreenControl: false,
            styles: mapStyle,
            gestureHandling: 'greedy',
            draggable: !('ontouchend' in document)
          };
          this.map = new google.maps.Map(this.$el, config);
          return Promise.resolve(getGeocode$1(this.stores)).then(function ($await_2) {
            try {
              storeGeocodeResults = $await_2;
              this.map.setCenter(storeGeocodeResults[0].geometry.location);
              this.map.fitBounds(storeGeocodeResults[0].geometry.viewport);
              this.map.setZoom(12);
              this.initStoreMarkers(storeGeocodeResults);
              return $Try_1_Post();
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }.bind(this), $Try_1_Catch);
        } catch (error) {
          $Try_1_Catch(error);
        }
      }.bind(this));
    },
    initStoreMarkers: function initStoreMarkers(storeGeocodeResults) {
      var _this2 = this;

      var locations = storeGeocodeResults.map(function (storeGeocode) {
        return {
          position: storeGeocode.geometry.location
        };
      });
      var markers = locations.map(function (x, i) {
        return new google.maps.Marker(Object.assign({}, x, {
          map: _this2.map,
          icon: _this2.markerIcon.inactive,
          store: _this2.stores[i]
        }));
      });
      this.storeMarkers = markers;
      markers.forEach(function (marker) {
        marker.addListener('click', function (e) {
          return _this2.$emit('set-selected-store', marker.store);
        });
      });
    }
  }
};

var storeTile = {
  props: ['store', 'distance', 'isFavoritedStore'],
  template: "\n    <div\n      @click='$emit(\"set-selected-store\", store)'\n      class='de-StoreTile de-u-pad03 de-u-padEnds de-u-cursorPointer'\n    >\n      <div class='de-Grid de-u-textSizeBase'>\n        <div class='de-StoreTile-info de-u-size4of6 de-u-padRight06'>\n          <h3\n            v-text='store.title'\n            class='de-StoreTile-name de-u-textGrow de-u-spaceNone de-u-textBold'\n          ></h3>\n          <div class='de-StoreTile-address de-u-flex'>\n            <p\n              v-text='store.street1'\n              class='de-u-spaceNone de-u-textShrink1 de-u-textDarkGray'\n              ></p>\n            <a\n              v-text='distance'\n              @click='$emit(\"store-direction-nav\", store)'\n              class='de-u-spaceLeft06 de-u-textShrink1 de-u-textBlue de-u-textMedium'\n            ></a>\n          </div>\n          <div v-if='(store.tooltip_hours === true)'>\n            <p\n              v-text='store.street2'\n              class='de-u-spaceNone de-u-textDarkGray de-u-textShrink2 de-u-textMedium de-StoreTile-tooltipOpener'\n            >\n            </p>\n            <div class='de-StoreTile-tooltip'>\n              <div class='tooltip-content'>\n                <h4 v-text='store.title'></h4>\n                <hr/>\n                <p>\n                  <strong>Address:</strong>\n                  <span v-text='store.street1'></span>,\n                  <span v-text='store.city'></span>,\n                  <span v-text='store.state'></span>,\n                  <span v-text='store.zip'></span>\n                </p>\n                <p><strong>Trading hours</strong></p>\n                <ul class='fullhours-list' v-html='store.fullHours'></ul>\n                <p v-if='(store.announcement !== \"\")'\n                  v-html='store.announcement'\n                  class='tooltip-announcement'></p>\n              </div>\n            </div>\n          </div>\n          <div v-else>\n            <p\n              v-text='store.street2'\n              class='de-u-spaceNone de-u-textDarkGray de-u-textShrink2 de-u-textMedium'\n            >\n            </p>\n          </div>\n        </div>\n        <div class='de-StoreTile-actions de-u-size2of6 de-u-textShrink2 de-u-flex'>\n          <a\n            v-if='store.test_mode === false'\n            @click='$emit(\"set-favorited-store\", store)'\n            class='de-StoreTile-actionsButton de-u-flex de-u-flexCol de-u-flexAlignItemsCenter de-u-flexJustifyCenter de-u-spaceRight03'\n          >\n            <span\n              v-html='icons.star'\n               class='de-u-iconContainer'\n              v-show='!(isFavoritedStore && isFavoritedStore.id === store.id)'\n            ></span>\n            <span\n              v-html='icons.starSolid'\n                class='de-u-iconContainer'\n              v-show='isFavoritedStore && isFavoritedStore.id === store.id'\n            ></span>\n            <span class='de-u-textBlue de-u-textMedium de-u-textShrink1'>Favorite</span>\n          </a>\n          <a\n            v-bind:href=\"store.page_info_url\"\n            class='de-StoreTile-actionsButton de-u-flex de-u-flexCol de-u-flexAlignItemsCenter de-u-flexJustifyCenter'\n          >\n            <span\n              v-html='icons.information'\n               class='de-u-iconContainer'\n            ></span>\n            <span class='de-u-textBlue de-u-textMedium de-u-textShrink1'>Info</span>\n          </a>\n        </div>\n      </div>\n    </div>\n  ",
  data: function data() {
    return {
      icons: {
        information: information,
        star: star,
        starSolid: starSolid
      }
    };
  }
};

var noLocations = {
  inheritAttrs: false,
  props: ['search-input', 'search-input-placeholder', 'email-input-placeholder'],
  template: "\n    <section class='de-StoreNoLocations de-u-textSizeBase de-u-spaceTop'>\n      <p class='de-u-textDarkGray de-u-spaceBottom de-u-textShrink1'>We don't have a store in <span class='de-u-textBold de-u-textShrink1'>{{ searchInput || searchInputPlaceholder }}</span> yet.</p>\n      <form\n        @submit.prevent='$emit(\"form-submit\")'\n        class='de-SingleInputForm de-u-hidden'\n      >\n        <p class='de-u-textDarkGray de-u-spaceNone de-u-textShrink1'>Enter an email address</p>\n        <div class='de-StoreNoLocations-inputWrapper de-u-spaceEnds03 de-u-flex de-u-bgSilver'>\n          <input\n            v-bind='$attrs'\n            v-on='listeners'\n            @blur='isFocused = false'\n            @focus='isFocused = true'\n            :placeholder='emailInputPlaceholder'\n            type='email'\n            required='true'\n            class='de-Input de-SingleInputForm-input de-u-textShrink1 de-u-bgSilver de-StoreNoLocations-input'\n          >\n          <button\n            class='de-SingleInputForm-action de-StoreNoLocations-submit de-u-textBold de-u-textShrink1 de-u-bgBlue de-u-textUpper'\n          >Submit</button>\n        </div>\n        <div class='de-u-flex de-u-flexAlignItemsCenter'>\n          <div\n            @click='isCheckboxActive = !isCheckboxActive'\n            :class='{ \"de-u-bgBlue\": isCheckboxActive }'\n            class='de-StoreNoLocations-checkbox de-u-flex de-u-flexAlignItemsCenter de-u-flexJustifyCenter de-u-spaceRight06 de-u-cursorPointer'\n          >\n            <input\n              v-model='isCheckboxActive'\n              type='checkbox'\n              class='de-u-hiddenVisually'\n            >\n            <span\n              v-show='isCheckboxActive'\n              v-html='icons.checkmark'\n              class='de-u-flex'\n            ></span>\n          </div>\n          <p class='de-u-spaceNone de-u-textShrink1'>Subscribe to newsletter</p>\n        </div>\n      </form>\n    </section>\n  ",
  data: function data() {
    return {
      icons: {
        checkmark: checkmark
      },
      input: '',
      isFocused: false,
      isCheckboxActive: false
    };
  },
  computed: {
    listeners: function listeners() {
      var _this = this;

      return Object.assign({}, this.$listeners, {
        input: function input(event) {
          return _this.$emit('input', event.target.value);
        }
      });
    }
  },
  watch: {
    isCheckboxActive: function isCheckboxActive(_isCheckboxActive) {
      this.$emit('checkbox-toggle', _isCheckboxActive);
    }
  }
};

/**
 * Initialize Vue instance
 */

var app = {
  name: 'app',
  template: "\n    <div class='de-StoreFinder de-u-bgLightGray'>\n\n      <div class='de-StoreController de-u-pad de-u-textSizeBase'>\n\n        <h2 class='de-u-textBold de-u-textCapitalize de-u-textGrow de-u-spaceBottom06'>Store Finder</h2>\n        <hr class='de-blue-hr de-u-bgBlue de-u-spaceNone'>\n\n        <store-finder-search-form\n          v-model.trim='searchInput'\n          @blur='handleSearchFormBlur'\n          @focus='handleSearchFormFocus'\n          @form-submit='handleSearchFormSubmit'\n          @clear-search-input='clearSearchInput'\n          @get-user-geolocation='getUserGeolocation'\n          :search-input='searchInput'\n          :search-input-placeholder='searchInputPlaceholder'\n          :geolocation-copy='geolocationCopy'\n        ></store-finder-search-form>\n\n        <store-finder-no-locations\n          v-model.trim='emailInput'\n          v-show='showNoLocations'\n          @form-submit='handleEmailFormSubmit'\n          @checkbox-toggle='handleEmailCheckboxToggle'\n          :search-input='noLocationCopy'\n          :search-input-placeholder='searchInputPlaceholder'\n          :email-input-placeholder='emailInputPlaceholder'\n        ></store-finder-no-locations>\n\n        <section\n          v-show='showStoreTiles'\n          class='Section Section--unique'\n        >\n          <store-finder-store-tile\n            v-for='(store, i) in stores'\n            :key='store + i'\n            @set-selected-store='setSelectedStore'\n            @set-favorited-store='setFavoritedStore'\n            @store-direction-nav='goToStoreDirection'\n            :store='store'\n            :distance='store.distance'\n            :is-favorited-store='isFavoritedStore'\n            :class='{ \"de-is-active\": isSelectedStore && isSelectedStore.id === store.id }'\n          ></store-finder-store-tile>\n        </section>\n\n        <div\n          v-show='showLoader'\n          :class='{ \"de-u-flex\": showLoader }'\n          class='de-StoreController-loader de-u-flexAlignItemsCenter de-u-flexJustifyCenter'\n        >\n          <img\n            class='de-StoreController-loaderImage'\n            src='https://cdn.shopify.com/s/files/1/1752/4727/t/77/assets/ajax-loader.gif'\n          >\n        </div>\n      </div>\n\n      <store-finder-map\n        v-if='stores.length > 0 && mapsInitialized && isStoresInitialized'\n        @set-selected-store='setSelectedStore'\n        :is-selected-store='isSelectedStore'\n        :initialStores='stores'\n        class='de-StoreMap'\n      ></store-finder-map>\n    </div>\n  ",
  components: {
    'store-finder-search-form': searchForm,
    'store-finder-map': map,
    'store-finder-store-tile': storeTile,
    'store-finder-no-locations': noLocations
  },
  data: function data() {
    return {
      isStoresInitialized: false,
      mapsInitialized: Boolean(window.google),
      stores: [],
      isStoreDistanceFetch: false,
      isFavoritedStore: null,
      isSelectedStore: null,
      isSearchInputFocused: false,
      isSearchInputCleared: false,
      searchInput: '',
      searchInputPlaceholder: '',
      searchInputPrevious: '',
      emailInput: '',
      emailInputPlaceholder: 'youremail@domain.com',
      isEmailCheckboxActive: false,
      userLocationZip: '',
      geolocationCopy: 'Use my location',
      noLocationCopy: '',
      outOfAreaThreshold: 100
    };
  },
  computed: {
    isStoresOutOfArea: function isStoresOutOfArea() {
      var _this = this;

      return this.stores.every(function (store) {
        return store.distanceFloat >= _this.outOfAreaThreshold;
      });
    },
    showStoreTiles: function showStoreTiles() {
      return this.isStoresInitialized && !this.isStoreDistanceFetch;
    },
    showLoader: function showLoader() {
      return !this.isStoresInitialized || this.isStoreDistanceFetch;
    },
    showNoLocations: function showNoLocations() {
      return this.isStoresInitialized && !this.isStoreDistanceFetch && this.isStoresOutOfArea;
    }
  },
  beforeMount: function beforeMount() {
    this.init();
  },
  methods: {
    init: function init() {
      return new Promise(function ($return, $error) {
        var $Try_1_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_1_Catch = function (error) {
          try {
            console.error(error);
            throw error;
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(Promise.all([this.fetchStoreList(), this.fetchUserLocation(), this.loadGoogleMaps()])).then(function ($await_11) {
            try {
              return Promise.resolve(this.getDistance(this.searchInputPlaceholder)).then(function ($await_12) {
                try {
                  this.getFavoritedStore();
                  this.isStoresInitialized = true;
                  return $Try_1_Post();
                } catch ($boundEx) {
                  return $Try_1_Catch($boundEx);
                }
              }.bind(this), $Try_1_Catch);
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }.bind(this), $Try_1_Catch);
        } catch (error) {
          $Try_1_Catch(error);
        }
      }.bind(this));
    },
    loadGoogleMaps: function loadGoogleMaps() {
      return new Promise(function ($return, $error) {
        var $Try_2_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_2_Catch = function (error) {
          try {
            console.error(error);
            throw error;
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          if (!this.mapsInitialized) {
            return Promise.resolve(_loadGoogleMaps()).then(function ($await_13) {
              try {
                this.mapsInitialized = true;
                return $If_9.call(this);
              } catch ($boundEx) {
                return $Try_2_Catch($boundEx);
              }
            }.bind(this), $Try_2_Catch);
          }

          function $If_9() {
            return $Try_2_Post();
          }

          return $If_9.call(this);
        } catch (error) {
          $Try_2_Catch(error);
        }
      }.bind(this));
    },
    fetchStoreList: function fetchStoreList() {
      return new Promise(function ($return, $error) {
        var stores;

        var $Try_3_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_3_Catch = function (error) {
          try {
            console.error(error);
            return $Try_3_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(fetchStores()).then(function ($await_14) {
            try {
              stores = $await_14;
              this.stores = stores.filter(function (store) {
                return !store.test_mode;
              }).map(function (store) {
                return Object.assign({}, store, {
                  distance: '',
                  distanceInt: ''
                });
              });
              return $Try_3_Post();
            } catch ($boundEx) {
              return $Try_3_Catch($boundEx);
            }
          }.bind(this), $Try_3_Catch);
        } catch (error) {
          $Try_3_Catch(error);
        }
      }.bind(this));
    },
    fetchUserLocation: function fetchUserLocation$1() {
      return new Promise(function ($return, $error) {
        var userLocation, city, state;

        var $Try_4_Catch = function (error) {
          try {
            console.error(error);
            throw error;
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(fetchUserLocation()).then(function ($await_15) {
            try {
              userLocation = $await_15;
              city = userLocation.city, state = userLocation.region_code;

              if (city && state) {
                this.searchInputPlaceholder = city + ", " + state;
              }

              return $return({
                city: city,
                state: state
              });
            } catch ($boundEx) {
              return $Try_4_Catch($boundEx);
            }
          }.bind(this), $Try_4_Catch);
        } catch (error) {
          $Try_4_Catch(error);
        }
      }.bind(this));
    },
    getUserGeolocation: function getUserGeolocation() {
      return new Promise(function ($return, $error) {
        var $Try_5_Finally = function ($Try_5_Exit) {
          return function ($Try_5_Value) {
            try {
              this.geolocationCopy = 'Use my location';
              return $Try_5_Exit && $Try_5_Exit.call(this, $Try_5_Value);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this);
        }.bind(this);

        var userGeolocation, latLng, res, city, state;

        var $Try_5_Catch = function (error) {
          try {
            console.error(error);
            throw error;
          } catch ($boundEx) {
            return $Try_5_Finally($error)($boundEx);
          }
        };

        try {
          this.geolocationCopy = 'Location...';
          return Promise.resolve(_getUserGeolocation()).then(function ($await_16) {
            try {
              userGeolocation = $await_16;
              latLng = {
                lat: userGeolocation.coords.latitude,
                lng: userGeolocation.coords.longitude
              };
              return Promise.resolve(getReverseGeocode(latLng)).then(function ($await_17) {
                try {
                  res = $await_17;
                  city = false;
                  state = false;
                  res.address_components.forEach(function (component) {
                    /* eslint-disable camelcase */
                    var types = component.types,
                        short_name = component.short_name;

                    if (types.includes('locality')) {
                      city = short_name;
                    } else if (types.includes('administrative_area_level_1')) {
                      state = short_name;
                    }
                    /* eslint-enable */

                  });

                  if (city && state) {
                    this.searchInputPlaceholder = city + ", " + state;
                    this.noLocationCopy = city + ", " + state;
                    this.clearSearchInput();
                    return Promise.resolve(this.getDistance(this.searchInputPlaceholder)).then(function ($await_18) {
                      try {
                        return $If_10.call(this);
                      } catch ($boundEx) {
                        return $Try_5_Catch($boundEx);
                      }
                    }.bind(this), $Try_5_Catch);
                  }

                  function $If_10() {
                    return $Try_5_Finally($return)({
                      city: city,
                      state: state
                    });
                  }

                  return $If_10.call(this);
                } catch ($boundEx) {
                  return $Try_5_Catch($boundEx);
                }
              }.bind(this), $Try_5_Catch);
            } catch ($boundEx) {
              return $Try_5_Catch($boundEx);
            }
          }.bind(this), $Try_5_Catch);
        } catch (error) {
          $Try_5_Catch(error);
        }
      }.bind(this));
    },
    getDistance: function getDistance(origin) {
      return new Promise(function ($return, $error) {
        var $Try_6_Finally = function ($Try_6_Exit) {
          return function ($Try_6_Value) {
            try {
              this.isStoreDistanceFetch = false;
              return $Try_6_Exit && $Try_6_Exit.call(this, $Try_6_Value);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this);
        }.bind(this);

        var destinations, distances;

        var $Try_6_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_6_Catch = function (error) {
          try {
            console.error(error);
            return $Try_6_Finally($Try_6_Post)();
          } catch ($boundEx) {
            return $Try_6_Finally($error)($boundEx);
          }
        };

        try {
          this.isStoreDistanceFetch = true;
          destinations = this.stores.map(function (store) {
            return formatStoreAddress(store);
          });
          return Promise.resolve(_getDistance({
            origin: origin,
            destinations: destinations
          })).then(function ($await_19) {
            try {
              distances = $await_19;

              if (distances.length > 0) {
                this.stores = this.stores.map(function (store, i) {
                  return Object.assign({}, store, {
                    distance: distances[i],
                    distanceFloat: parseFloat(distances[i].replace(/,/g, ''), 10)
                  });
                }).sort(function (a, b) {
                  return a.distanceFloat - b.distanceFloat;
                });
              }

              return $Try_6_Finally($return)(distances);
            } catch ($boundEx) {
              return $Try_6_Catch($boundEx);
            }
          }.bind(this), $Try_6_Catch);
        } catch (error) {
          $Try_6_Catch(error);
        }
      }.bind(this));
    },
    handleSearchFormSubmit: function handleSearchFormSubmit() {
      return new Promise(function ($return, $error) {
        var origin;
        if (!this.searchInput) return $return();

        var $Try_7_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_7_Catch = function (error) {
          try {
            console.error(error);
            return $Try_7_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          // Store input for the event of no distance results
          this.noLocationCopy = this.searchInput;
          this.searchInputPrevious = this.searchInput;
          origin = this.searchInput;
          return Promise.resolve(this.getDistance(origin)).then(function ($await_20) {
            try {
              return $Try_7_Post();
            } catch ($boundEx) {
              return $Try_7_Catch($boundEx);
            }
          }, $Try_7_Catch);
        } catch (error) {
          $Try_7_Catch(error);
        }
      }.bind(this));
    },
    handleSearchFormBlur: function handleSearchFormBlur() {
      this.isSearchInputFocused = false;

      if (this.searchInput.length === 0 && this.searchInput !== this.searchInputPrevious) {
        this.getDistance(this.searchInputPlaceholder);
        this.noLocationCopy = this.searchInput;
        this.isSearchInputCleared = false;
      }
    },
    handleSearchFormFocus: function handleSearchFormFocus() {
      this.isSearchInputFocused = true;

      if (!this.isSearchInputCleared) {
        this.searchInputPrevious = this.searchInput;
      }
    },
    clearSearchInput: function clearSearchInput() {
      this.isSearchInputCleared = true;
      this.searchInputPrevious = this.searchInput;
      this.searchInput = '';
    },
    handleEmailFormSubmit: function handleEmailFormSubmit() {
      return new Promise(function ($return, $error) {
        var _this2, emailAddress, newsletterSubscribe, url;

        _this2 = this;
        emailAddress = this.emailInput;
        newsletterSubscribe = "" + this.isEmailCheckboxActive;
        if (!emailAddress) return $return();

        var $Try_8_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        var $Try_8_Catch = function (error) {
          try {
            console.error(error);
            this.emailInput = emailAddress;
            return $Try_8_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this);

        try {
          this.emailInput = '';
          url = 'https://decathlon-proxy.herokuapp.com/api/mailchimp';
          return Promise.resolve(fetch(url, {
            method: 'POST',
            body: JSON.stringify({
              emailAddress: emailAddress,
              newsletterSubscribe: newsletterSubscribe
            }),
            headers: {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',
              'Content-Type': 'application/json'
            }
          })).then(function ($await_21) {
            try {
              this.emailInputPlaceholder = 'Thank you for signing up!';
              setTimeout(function () {
                _this2.emailInputPlaceholder = 'youremail@domain.com';
              }, 3000);
              return $Try_8_Post();
            } catch ($boundEx) {
              return $Try_8_Catch($boundEx);
            }
          }.bind(this), $Try_8_Catch);
        } catch (error) {
          $Try_8_Catch(error);
        }
      }.bind(this));
    },
    handleEmailCheckboxToggle: function handleEmailCheckboxToggle(checkboxState) {
      this.isEmailCheckboxActive = checkboxState;
    },
    setSelectedStore: function setSelectedStore(store) {
      this.isSelectedStore = store;
    },
    setFavoritedStore: function setFavoritedStore(store) {
      if (this.isFavoritedStore && this.isFavoritedStore.id === store.id) {
        this.deleteFavoritedStore();
      } else {
        this.isFavoritedStore = store;
        setObjectInLocalStorage('favoritedStore', store);
      }
    },
    getFavoritedStore: function getFavoritedStore() {
      var favoritedStore = getObjectFromLocalStorage('favoritedStore');

      if (favoritedStore && this.stores.filter(function (store) {
        return store.id === favoritedStore.id;
      })[0]) {
        this.isFavoritedStore = favoritedStore;
      }
    },
    deleteFavoritedStore: function deleteFavoritedStore() {
      if (this.isFavoritedStore) {
        removeItemFromLocalStorage('favoritedStore');
        this.isFavoritedStore = null;
      }
    },
    goToStoreDirection: function goToStoreDirection(store) {
      var directions = {
        origin: this.searchInput || this.searchInputPlaceholder,
        destination: formatStoreAddress(store)
      };
      var url = "https://www.google.com/maps/dir/?api=1&" + objectToParams(directions);

      if (url) {
        window.location.href = url;
      }
    }
  }
};

new Vue({
  render: function render(h) {
    return h(app);
  }
}).$mount('#js-StoreFinder');
